算法题目：

从数组中找出连续数组乘积最大 <font color=red> 完成 </font>

假设有两个整数a，b. 那么a/b有可能除尽和除不尽。如果除尽，找出循环的单节。图论。

假设一个数组只有"a"和“b”两种string 组成。如何重新安排数组，使得最多有3个a相邻，3个b相邻。如果不能安排，返回None

假设有a，b两个int，转成二进制后 c = a | b. 假设从0->1, 1->0理解为一个action。最少需要多少个action计算c = a|b？

如何实现a/b。a和b是string，返回double。不难。

最早公共祖先 <font color=red> 完成 </font>

开根号（平方根）<font color=red> 完成 </font>

已知前序和中序求[二叉树](https://www.nowcoder.com/jump/super-jump/word?word=二叉树)，延申：前序遍历和中序遍历有重复元素呢？ <font color=red> 完成 </font>

一个有序数组反转一次，O(logN)复杂度进行搜索，延申：数组有重复元素呢?

后续非遍历

全排列（相邻字符不能相同） <font color=red> 完成 </font>

47，全排列2 <font color=red> 完成 </font>

给定一个二维矩阵，包括0和非0，把0所在的行和列都置为0。

跳台阶，两个参数（n级台阶，最多迈k步，也就是dp[i] = dp[i-1] + dp[i-2] + ... + dp[i-k], k阶以前的值需要预先算出来）<font color=red> 完成 </font>

搜索旋转排序数组。写代码之前记得问有没有重复元素这类二分可能会遇到坑，面试官很nice 很乐意多交流，另外ms的面试风格，一定要自己想test case，尽可能的覆盖所有边界条件)  <font color=red> 完成 </font>

两个长度为m的无序数组A，B，对于任意不相交的区间ab和cd，val[ab]=sum（A，a，b）- sum（B，a，b），val[cd] = sum（B，c，d）- sum（A，c, d）
求abcd，使val[ab] + val[cd]最大 (这题比较难，先写了个暴力解法，然后和面试官逐步讨论优化，没有给出最优解法)

前序遍历 中序遍历 后序遍历 知道那些可以恢复[二叉树](https://www.nowcoder.com/jump/super-jump/word?word=二叉树)，只知道前序和后序可以吗？原因？

无序数组找第k大的数 <font color=red> 完成，堆排序 </font>

一个字符串 切分成多个回文串，返回所有可能，如aab要返回 [[aa,b],[a,a,b]] (印象里应该是LeetCode原题)

实现atoi 考虑所有情况 (LeetCode medium，记得考虑所有异常情况，包括溢出)

二叉树层次遍历 <font color=red> 完成 </font>

有序矩阵查找

编辑距离 <font color=red> 完成 </font>

区间合并（首先对其所有区间进行排序，从第一个区间开始，比较这个区间的左边界是否小于前一个区间的右边界，小于可以合并；取最大范围）<font color=red> 完成 </font>

求逆序对个数（nlgn，线段树或树状数组） <font color=red> 完成 </font>

`leetcode629` (dp)

螺旋矩阵

区域和检索，数组可修改

992 K 个不同整数的子数组

字典数

209

连续无重复子串 <font color=red> 完成 </font>

删除一个字符串链表中的指定字符串

第一个不重复的字符串

青蛙跳台阶 <font color=red> 完成 </font>

二叉树的中序遍历递归非递归方式 <font color=red> 完成 </font>

反转链表，后边k个元素移到前边去，快慢指针。

O(n)时间复杂度计算排名系数，若干名学生，计算每个人的排名系数=比自己低的人数包括自己/总人数

两数之和（哈希表）<font color=red> 完成 </font>

接雨水 <font color=red> 完成 </font>

合并K个[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)：由合并两个[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)去归并。

字符串的全排列，问了时间复杂度（O（n*n！）），以及详细的时间复杂度推导（n是怎么来的，n！是怎么来的），怎么优化（DFS剪枝）。

674，求无序数组的不连续递增子序列



#### 25匹马，5个跑道，不计时，最少比多少次能比出前3名，前5名

+ 求前3名（答案：7场比赛）
  + 将马分成A，B，C，D，E五组，分别进行5场比赛，决出各组名次，取每组前三名
  + 第6场比赛，将上一场比赛的每组第一名拿出来进行比赛，假设比赛名次分别为：A1，B1，C1，D1，E1；A1是第一名，A2，A3还有希望冲进决赛，B1，B2还有希望冲进决赛，C1还有希望（并且由于C1已经是这场比赛的第三名了，D1，E1一定没有机会）
  + 第7场比赛：A2，A3，B1，B2，C1，比出前2名，分别是总排名的第2名，第3名
+ 求前5名（答案：8场比赛）
  + 将马分成A，B，C，D，E五组，分别进行5场比赛，决出各组名次
  + 第6次比赛：将上一场比赛的每组第一名拿出来进行比赛，假设比赛名次分别为：A1，B1，C1，D1，E1；A1是第一名，最快的
  + 第7场比赛：将上次第一名所在组的下一号马再和剩余的4匹1号马比赛，第一名是跑的第二快的马，由于只有4个名额，所以跑的最慢的马和所在组剩余的马全部被淘汰。例如，拿B1，C1，D1，E1和A2进行比较，假设结果为B1，C1，A2，D1，E1，其中B1最快，C1第二快，E1最慢，那么E组整个都被淘汰
  + 第8次比赛：将上次第一名所在组的下一号马（也就是B2）、上次第二名所在组的下一号马（C2）和剩余的3匹马比赛（C1，A2，D1），去掉跑的最慢的两匹马，可以得到最快的前3名，分别是总排名的第3，4，5名（第一名来自第6场比赛，第二名来自第7场比赛）

#### 64匹马，8个跑道，不计时，最少比多少次能比出前4名

+ 把64匹马分8组，各跑一次，然后淘汰掉每组的后四名，这里淘汰后四名是因为只需要跑的最快的四匹马。（8轮）
+ 取每组第一名进行一次比赛，然后淘汰最后四名所在组的所有马，因为后四名所在的组的第一名没有跑过前四名的马，所以可以直接淘汰。（+1轮）；
+ 这时候还剩下16匹马，在这里其实可以继续淘汰，因为D1是第九轮的第四名，但D1又是它3所在组的第一名，那么对应的D2，D3，D4都可以继续淘汰掉。但是第四名也可能出现在C2中，C2是所在组的第二名，那么C3，C4也可以淘汰了，同理，可以得到B4也可以淘汰了。到此为止还剩10匹马，其中A1是64匹马中跑的最快的马，可以直接晋级。
+ A2、A3、A4、B2、B3、C1、C2、D1 8匹马跑一次，即：在剩下需要排名的马中，除了B1外，其它8匹马跑一次（+1轮）
+ **分类讨论**：
  + 如果这次排名，B2或C1能进前三名，则加上B1后，B1一定能进前三名，因为B1 排名比B2和C1都要靠前；到此比赛可以结束了；**这种情况8+1+1＝10次出结果；**
  + 如果这次排名，B2或C1不能进入前三名，则需要**再进行一次**比赛，B1、A2、A3、A4进行，取前三名：**这种情况8+1+1+1=11次出结果。**
+ 计时的情况下需要比赛8轮，不计时的情况下至少需要10轮，最多需要11轮