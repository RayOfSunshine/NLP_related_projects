二叉树相关



1. 二叉搜索树：

+ 每个节点中的值必须<font color=red>大于</font>存储在其左子树中的任何值
+ 每个节点中的值必须<font color=red>小于</font>存储在其右子树中的任何值
+ 使用中序遍历能够得到一个递增的有序序列



2. 完全二叉树：

若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（注：第 h 层可能包含 1~ 2h 个节点。）

+ 验证方法：
  + 对于一个节点，它的左孩子为：`(depth, position) -> (depth + 1, position * 2)`，右孩子为 `(depth, position) -> (depth + 1, position * 2 + 1)`。所以，对于深度为 d 的行恰好含有 $2^{d-1}$ 个节点，所有节点都是靠左边排列的当他们的位置编号是 0, 1, ... 且没有间隙。



3. morris遍历模版：
   + 优点：常数空间实现遍历
   + 核心思想：利用树的大量空闲指针

```python
class Solution(object):
    def recoverTree(self, root):
        """具体任务出发，对使用到的变量进行初始化"""
        while root:
            """
            如果是中序遍历，那么先处理左子树，再处理右子树；这里以中序遍历为例
            如果是反序中序遍历，那么先处理右子树，在处理左子树
            """
            if root.left:
                # 如果当前节点左子树不为空，找到左子树的最右节点
                tmp = root.left
                while tmp.right and tmp.right != root:
                    tmp = tmp.right
                
                if not tmp.right:
                    # 如果当前节点的右子树为空，那么将当前节点的右子树链连接根节点
                    # 然后令当前节点的左子节点为当前节点，因为是中序遍历，探索到最左子树
                	tmp.right = root
                    tmp = tmp.left
                else:
                    # 如果当前节点的右子树不为空
                    """具体任务出发，对变量进行操作"""
                    # 将当前节点的右子树断开，根节点的右子树为新根节点
                    tmp.right = None
                    root = root.right
			else:
                # 如果左子树为空
                """具体任务出发，对变量进行操作，例如向结果中添加当前节点值等"""
                # 根节点的右子树为新根节点，这一步是回溯的关键（也就是省去栈空间的关键）
                root = root.right
                
        """具体任务出发，对变量进行最终操作"""
```



105，从前序与中序遍序列构造二叉树，中等

核心方法：递归

对于任意一棵树而言，前序遍历的结果总是：`[根结点，[左子树的前序结果]，[右子树的前序结果]]`

后序遍历的结果总是：`[[左子树的前序结果]，根结点，[右子树的前序结果]]`

只要在中序遍历中确定了根结点的位置，那么就可以知道左右子树的节点个数，这样就可以在前序遍历的结果中对左右括号进行定位。最后通过找到的左子树（右子树）的前序结果和中序结果，然后递归调用。

可以采用哈希映射将中序遍历中各个节点值对应的序号取出来，这样能够在O(1)复杂度内查到根结点的位置。

- 时间复杂度：O(n)，其中 n 是树中的节点个数。
- 空间复杂度：O(n)，除去返回的答案需要的 O(n) 空间之外，我们还需要使用 O(n) 的空间存储哈希映射，以及 O(h)（其中 h 是树的高度）的空间表示递归时栈空间。这里 h<n，所以总空间复杂度为 O(n)。


```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        def myBuildTree(pre_left, pre_right, in_left, in_right):
            if pre_left > pre_right:
                return None
            pre_root_index = pre_left  # 前序遍历中根结点的位置，也就是第一个
            in_root_index = index[preorder[pre_root_index]]  # 中序遍历结果中的根节点

            # 把当前根节点建立出来
            root = TreeNode(preorder[pre_root_index])
            # 左子树的节点数目
            left_subtree_size = in_root_index - in_left

            # 构造左子树
            root.left = myBuildTree(pre_left+1, pre_left+left_subtree_size, in_left, in_root_index-1)
            # 构造右子树
            root.right = myBuildTree(pre_left+left_subtree_size+1, pre_right, in_root_index+1, in_right)
            return root
        
        n = len(preorder)
        index = {element: i for i, element in enumerate(inorder)}
        return myBuildTree(0 ,n-1, 0, n-1)
```



101，对称二叉树，简单

核心方法：递归。注意三个终止条件

+ 时间复杂度：这里遍历了这棵树，渐进时间复杂度为 O(n)。

+ 空间复杂度：这里的空间复杂度和递归使用的栈空间有关，这里递归层数不超过 n，故渐进空间复杂度为 O(n)。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if not root: return True
        def next(l, r):
            # 结束条件
            if not l and not r:
                # 左右节点都为空
                return True
            if not l or not r:
                # 左右节点有一个为空
                return False
            if l.val != r.val:
                # 左右节点值不想等
                return False
            return next(l.left, r.right) and next(l.right, r.left)
        return next(root.left, root.right)
```

核心方法：迭代，使用队列。如果当前节点满足条件，就将下面待比较的每组添加到队列中，直到队列为空

+ 时间复杂度：O(n)

+ 空间复杂度：O(n)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        # 使用队列
        if not root: return True
        q = [(root.left, root.right)]
        
        while q:
            left, right = q.pop()
            if not left and not right:
                continue
            
            if left and right and left.val == right.val:
                q.append((left.left, right.right))
                q.append((left.right, right.left))
            else:
                return False
        return True
```



98，验证二叉搜索树，中等

核心方法：递归，在向下探索的过程中，不断检查左子节点，右子节点和根结点的关系是否满足条件；只要不满足条件，直接return False

时间复杂度：O(n)

空间复杂度：O(n)，树高最高为n

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        if not root: 
            return True

        def search(node, min_v, max_v):
            if not node: 
                return True

            if node.left:
                if node.left.val >= node.val or node.left.val <= min_v:
                    return False

            if node.right:
                if node.right.val <= node.val or node.right.val >= max_v:
                    return False

            return search(node.left, min_v, node.val) and search(node.right, node.val, max_v)
        
        # 这里设置最小值和最大值，初始化最小值很小，最大值很大
        # 在向下递归的过程中，如果左子节点值小于最小值，右子节点值大于最大值，全部返回False
        return search(root, -2**32, 2**32)
```

根据搜索二叉树的性质，中序遍历得到的结果一定是升序的。那么通过迭代的方法，中序遍历这个树，分别记录每个节点的值，然后判断当前遍历到的值是否大于上一个值，如果不大于，则return False，全遍历完后return True。使用栈来维护每个根结点。

```python
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        stack, inorder = list(), float('-inf')
        
        while stack or root:
            while root:
                stack.append(root)
                root = root.left
            root = stack.pop()
            if root.val <= inorder:
                return False
            inorder = root.val
            root = root.right
            
        return True
```



226，翻转二叉树，简单

核心方法：向下进行递归，分别取当前节点的左子节点和右子节点，然后分别将他们赋值给当前节点的右子树和左子树

时间复杂度：O(N)，每个节点遍历一遍，在常数空间内交换两颗树

空间复杂度：O(N)，使用的空间由递归栈的深度决定。最坏情况下，树形成链状，空间复杂度为O(N)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return root
        
        left = self.invertTree(root.left)
        right = self.invertTree(root.right)
        root.left, root.right = right, left
        return root
```



543，二叉树的直径，简单

核心方法：向下递归，找到每个节点的左最大深度和右最大深度，+1得到当前节点下的最多节点路径。比较每个节点的最多节点路径并维护。遍历完成后，最长直径等于最多节点路径上的最长直径，也就是节点数-1

时间复杂度：O(N)

空间复杂度：O(N)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        # 维护一个变量记录每次递归完成后的路径经的所有节点数
        self.ans = 1
        def depth(node):
            if not node: return 0
            # 先找到每个根节点的左子树节点
            L = depth(node.left)
            # 再找到每个根节点的右子树节点
            R = depth(node.right)
            # 更新最多的节点数，加1表示计算了当前节点
            self.ans = max(self.ans, L+R+1)
            # 返回（左或右）最大深度，加1表示计算了当前节点
            return max(L, R) + 1

        depth(root)
        # 最长直径等于路径上最多节点数-1
        return self.ans - 1
```



110，平衡二叉树，简单

核心方法：从根节点开始，向下递归，检查左右子树是否是平衡的。递归返回的是从当前节点开始的最大深度（不忘记算上当前节点，要+1）。在递归的过程中，只要遇到某节点的左右子树有一个等于-1，即深度差大于1，就一直向上返回-1，在最顶端判断为False；否则判断为True

时间复杂度：O(N)

空间复杂度：O(N)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        def recur(root):
            if not root:
                return 0
            
            left = recur(root.left)
            if left == -1: 
                return -1
            
            right = recur(root.right)
            if right == -1: 
                return -1
            # 返回当前节点向下的深度
            return max(left, right) + 1 if abs(left- right) < 2 else -1
        
        return recur(root) != -1
```



剑指offer32，从上到下打印二叉树，中等

核心方法：二叉树的层级遍历，使用队列。将每个节点放进队列。从队列中取出一个节点，将其值保存，将其左右节点加入队列。

时间复杂度：O(N)

空间复杂度：O(N)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def levelOrder(self, root: TreeNode) -> List[int]:
        if not root: return []
        queue = [root]
        res = list()
        while queue:
            node = queue.pop(0)
            res.append(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        return res
```



297，二叉树的序列化与反序列化，困难

核心方法：

+ 序列化的方法使用层级遍历的方式，要注意的是如果遍历的节点为空，那么需要向结果列表中添加 ‘None’。返回时需要注意将结果列表变为字符串
+ 反序列化的方法，首先将第一个值进行节点化，将当前节点放入双端队列。只要队列不为空，就弹出一个节点，按顺序取序列化列表中两个值，只要不为空，就分别将他们设置为节点然后接在当前节点下，成为左子节点和右子节点。最后返回root节点就行。
+ 时间复杂度：O(N)
+ 空间复杂度：O(N)

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        if not root: return ''
        queue = [root]
        res = list()
        while queue:
            node = queue.pop(0)
            if node:
                res.append(str(node.val))
                queue.append(node.left) 
                queue.append(node.right)
            else:
                res.append('None')
        return '[' + ','.join(res) + ']'
        

    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        if not data: return []
        datalist = data[1:-1].split(',')
        root = TreeNode(int(datalist[0]))
        queue = collections.deque([root])
        i = 1
        while queue:
            node = queue.popleft()
            if datalist[i] != 'None':
                node.left = TreeNode(int(datalist[i]))
                queue.append(node.left)
            i += 1
            
            if datalist[i] != 'None':
                node.right = TreeNode(int(datalist[i]))
                queue.append(node.right)
            i += 1
        return root

        

# Your Codec object will be instantiated and called as such:
# codec = Codec()
# codec.deserialize(codec.serialize(root))
```



236，二叉树的最近公共祖先，简单

核心方法：向下递归，如果当前节点为空，或者等于p或q中的一个，说明到头了；或是找到了p或q，此时返回当前节点。查看返回的左右节点，如果一个为空，那么就返回另一个。

也就是说，当向下递归找到p和q时，向上传递的就是p和q，或者为空。当遇到p和q的最近公共祖先时，返回的就是当前节点，也就是最近公共祖先，对应于函数最下面的 `return root`

+ 时间复杂度：O(N)
+ 空间复杂度：O(N)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root or root == p or root == q:
            return root
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        if not left: return right
        if not right: return left
        return root
```



671，二叉树中第二小的节点，简单

核心方法：递归+排序

使用哈希集合记录树中所有的唯一值，即使多个节点有相同值，值的唯一性会在集合中保证。递归完成后，将集合结果转化为列表，然后对其排序

+ 时间复杂度：递归为O(n)，排序复杂度为O(nlogn)，最大为O(nlogn)
+ 空间复杂度：在于哈希集合，最坏情况下为O(n)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findSecondMinimumValue(self, root: TreeNode) -> int:
        def dfs(node):
            if not node:
                return 
            vals.add(node.val)
            dfs(node.left)
            dfs(node.right)
        
        if not root: return -1
        vals = set()
        dfs(root)
        if len(vals) < 2:
            return -1
        res = list(vals)
        res.sort()
        return res[1]
```

只使用递归，如果当前节点不等于（根据这种树的性质，那就一定是大于）根节点的值，则比较（当前节点，递归左节点，递归右节点），找到最小值；反之则递归左右子节点，找最小值（不等于根节点的值）

时间复杂度： O(n)

空间复杂度： O(n)

```python
class Solution:
    def findSecondMinimumValue(self, root: TreeNode) -> int:
        judge = root.val
        def find(root):
            if not root:
                return 1000000000000
            if root.val == judge:
                return min(find(root.left),find(root.right))
            return min(root.val,find(root.left),find(root.right))
        second = find(root)
        return second if second !=1000000000000 else -1
```



440，字典序的第k小的数，困难

字典序表示的是，以数字`i`开头的数一定要排在以数字`i+1`开头的数的前面。

对`n=13`，排序的结果就是1，10，11，12，13，2，3，4，5，6，7，8，9

在计算第`k`个数时，假设知道数字`i`开头的数有`count`个，那么如果这个 `count > k` 时，说明就不需要再去看以数字 `i+1` 开头的数有多少个了，直接在 `count` 个数中找就行；如果 `count < k`，那就需要去以 `i+1`开头的数中寻找，所以我们首先需要确定

+ 以数字`i`开头的数有多少个？

首先我们需要确定一个区间，这个区间内的所有数都是以`i`开头的。首先我们可以确定区间的起始点就是`i`，区间的终点是`i+1`，并且只要`i <= n`，我们就能找到以数字`i`为起点的，不超过`n`的个数。每次累加以 `i` 为开头的数完成后，需要将`a*10`，`b*10`，这样做的原因是能够取到以 `i` 开头的，数长度从小到大的所有数。代码如下：

```python
def getCount(prefix, n):
    count = 0
    a = prefix
    b = prefix + 1
    while a <= n:
        count += min(n+1, b) - a
        a *= 10
        b *= 10
        return count 
```

模拟：

1. 以 `i` 开头的累加数是通过区间终点减去区间起点完成的。但是以 `i` 开头的数字不能超过最大数字 `n`，所以要在最大数字 `n+1` 和区间终点 `b` 之间取一个最小。
2. 数字`i`是逐步确定的，并且从`1`开始。用例子 `n = 13, k = 2` 进行一次简单的模拟。现在要计算以 `1` 为开头的数字个数，那么令`a=1，b=a+1=2，a<n 且 b < n+1`, 那么累加后的 `count = 1`，也就是在数长度为 `1` 时，以 `1` 开头的数只有 `1`，也就是`1`个；都乘以`10`后，`a=10，b = 20，a < n 但是 b > n+1`，那么区间长度就是 `n+1-a = 4`，就是以`1`开头的数，且长度为`2`的数有`10，11，12，13`；累加后的 `count` 等于 `5`，也就是以`1`开头的数为`1，10，11，12，13`，对应着正确的排序。

在确定以i开头的数字个数后，下一步需要确定排序后的第k个数，那么

+ 如何找到第k个数的位置？

假设所有排序的起点是p，我们指定p从1开始（因为要求的也是第k小的数，也就是排序结果中的第k个数）。那么我们判断位置p是否等于位置k。

当然位置p是一步步往向后取的，如果当前位置与以i开头的数字个数的和大于k，说明新产生的，以i开头的数字个数与上一步（i-1开头的数字个数）已经排序的序列结果拼接后，已经包含了位置k，那么这时需要将数字i*10，也就是进入到新增的序列中查找位置k，同时位置p向后移动一位，因为新数字i字典序向后移动一位了

```python
if p + cnt > k:
    prefix *= 10
    p += 1
```

模拟：承接上一个模拟结果，当p = 1，cnt = 5时，p + cnt > k，那么将p+=1，此时等于2；prefix * 10 = 10，将 prefix=10，n=13 再拿到 getCount 中进行计算。由上文可知，这个条件下getCount的计算结果是4，也就是序列`10，11，12，13`；此时的循环中p = k了，那么我们返回的prefix就是第k个数。

同理，如果当前位置与以i开头的数字个数的和小于等于k，说明新产生的，以i开头的数字个数与上一步（i-1开头的数字个数）已经排序的序列结果拼接后，还没有包含位置k，那么这时需要将数字i+=1，也就是获取下一个数开头的数字个数，同时位置p向后走过cnt个位置，因为这个cnt个位置不包含位置k，可以跳过。

```python
else:
    prefix += 1
    p += cnt
```

总的代码表示为：

```python
class Solution:
    def findKthNumber(self, n: int, k: int) -> int:
        def getCount(prefix, n):
            count = 0
            a = prefix
            b = prefix + 1
            while a <= n:
                count += min(n+1, b) - a
                a *= 10
                b *= 10
            return count 
        
        p = 1
        prefix = 1
        while p < k:
            cnt = getCount(prefix, n)
            if p + cnt > k:
                prefix *= 10
                p += 1
            else:
                prefix += 1
                p += cnt
        return prefix
```

时间复杂度：$O((log_{10}n)^2)$，两层循环嵌套，但是每10个遍历一次

空间复杂度：O(1)



386，字典序排数，中等

![字典树](https://tva1.sinaimg.cn/large/008i3skNgy1gspvmuumvmj30so0heabl.jpg)

字典树可以抽象为一颗树，根节点为0，下面展开为9个节点，因为字典序的第一个前缀的范围是从1到9的；这9个节点再往下展开的节点值的范围是从0到9的。

核心方法：递归

使用深度优先搜索，终止条件是节点的值 `i` 大于最大值 `n`，否则将 `i` 添加进结果中，然后开始从 `0` 到 `9` 遍历，作为接在 `i` 后面的数，下一个值就是 `i * 10 + j`。

+ 时间复杂度：
+ 空间复杂度：

```python
class Solution:
    def lexicalOrder(self, n: int) -> List[int]:
        res  = list()
        for i in range(1, 10):
            # 字典的第一个前缀是从1到9的
            self.dfs(n, i, res)
        return res

    def dfs(self, n, i, res):
        # i 表示字典序的序号
        if i > n:
            return 
        res.append(i)
        for j in range(10):
            # 每一个前缀下的数字范围都是0到9
            self.dfs(n, i*10+j, res)
```

核心方法：迭代方法 <font color=red> 推荐 </font>

```python
class Solution:
    def lexicalOrder(self, n: int) -> List[int]:
        res = list()
        cur = 1
        # 10叉树的前序遍历
        for _ in range(n):
            res.append(cur)
            if cur * 10 < n:
                cur *= 10  # 进行下一层
            else:
                if cur >= n:
                    # 当前层结束的话，就退回到上一层
                    cur = cur // 10
                cur += 1
                while cur % 10 == 0:
                    # 如果大于9就应该返回上一层
                    cur = cur // 10
        return res
```



814，二叉树剪枝，中等

核心方法：判断以node为根的子树中是否包含1。不包含1的情况对应，node本身不为1，且node的左右子节点为根时的左右子树都不包含1.

如果node的左右子节点为根的子树不包含1，那么我们就需要把对应的指针置为空。

在递归结束后，如果整个二叉树都不包含1，那么返回None，否则返回整棵树的根节点

时间复杂度：O(n)，n为节点个数

空间复杂度：O(h)，h 是树的高度，为我们在递归时使用的栈空间大小

```python
class Solution(object):
    def pruneTree(self, root):
        def containsOne(node):
            if not node: return False
            a1 = containsOne(node.left)
            a2 = containsOne(node.right)
            if not a1: node.left = None
            if not a2: node.right = None
            return node.val == 1 or a1 or a2

        return root if containsOne(root) else None
```



99，恢复二叉搜索树，中等

核心方法：将整个树通过中序遍历，依次保存树中的每个节点。保存节点的序列中应该是递增的，若只有两个节点被交换了。那么直接找到第一个递减位置的前一个位置（即被交换的第一个位置）。找到第二个递减位置（即被交换的第二个位置），互换即可。

时间复杂度：O(n)

空间复杂度：O(n)

```python
class Solution:
    def recoverTree(self, root: TreeNode) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
 		# 遍历整棵树
        out = list()
        def dfs(root):
            if not root:
                return 
            dfs(root.left)
            out.append(root)
            dfs(root.right)
        dfs(root)
        # 遍历找到需要替换位置的两个节点
        x, y = None, None
        pre = out[0]
        for i in range(1, len(out)):
            if pre.val >= out[i].val:
                # 记录第二个要替换的位置
                y = out[i]
                if not x:
                    # 记录第一个要替换的位置
                    x = pre
            pre = out[i]
        # 对节点内的两个值进行替换
        if x and y:
            x.val, y.val = y.val, x.val
```

核心方法：Morris遍历，使得空间复杂度为O(1)

对于某个节点，如果其左子树的右子树已经完成遍历了，那么对于递归来说，操作系统自动出栈，然后就会访问当前节点。<font color=red>假如我们直接将当前节点的左子树的右子树最后一个节点直接指向当前节点</font>，那么就省去了额外的栈空间。利用叶子节点的右子树这个特点，将其重新赋予指向关系，就是莫里斯遍历的核心。

==所谓新加的指向关系，就是找到根节点左子树的最右子树，然后将最右子树的right指向根节点。==

<font color=red>注意：新加的关系有可能使得原来的链式存储变成图，在遍历到某一根节点时，就可以将新加的，与其相连的节点的右子树重新置为空。</font>

比较好记的思路：从中序遍历上看

+ 拿到一个新的根节点，首先判断其左子节点是否存在，这符合中序遍历的要求
+ 循环检查当前节点是否存在右子节点，且右子节点不等于根节点，也就是找到根节点左子树的最右子树
+ 上一步结束的可能是因为右子树等于了根节点，所以还需要判断一次（当前节点的右子树为空），将当前节点的右子树节在根节点处，同时根节点继续向左子树移动，这也符合中序遍历的结果
+ 如果当前节点的右子树不为空，那么就需要计算前一个节点是否大于当前根节点，如果大于，说明找到了异常值。然后更新前一个节点为当前节点，更新根节点为当前根节点的右子树（目的是为了重新走一遍之前走过的路，将新加的最右子节点与根节点的连接断开）。

时间复杂度：O(n)

空间复杂度：O()

```python
class Solution(object):
    def recoverTree(self, root):
        x = None  # 记录找到的第一个要替换的值
        y = None  # 记录找到的第二个要替换的值
        pre = None  # 表示前一个节点，也就是中序遍历中上一个节点
        tmp = None  # 表示当前节点
        while root:
            if root.left:
                # 如果左子树存在，将左子树赋值给tmp
                tmp = root.left
                while tmp.right and tmp.right != root:
                    # 如果当前节点的右子树存在，且这个右子树不等于根节点
                    tmp = tmp.right
                if not tmp.right:
                    # 如果当前节点的右子树为空，那么将当前节点的右子树链连接根节点
                    # 然后令当前节点的左子节点为当前节点，因为是中序遍历，探索到最左子树
                	tmp.right = root
                    tmp = tmp.left
                else:
                    # 如果当前节点的右子树不为空
                    # 需要判断前一个节点和根节点的大小关系
                    if pre and pre.val>root.val:
                        y = root
                        if not x:
                            x = pre
                    # 将根节点赋值给前一个节点，将当前节点的右子树断开，根节点的右子树为新根节点
                    pre = root
                    tmp.right = None
                    root = root.right
			else:
                # 如果左子树不存在
                # 需要判断前一个节点和根节点的大小关系
                if pre and pre.val > root.val:
                    y = root
                    if not x:
                        x = pre
                # 将根节点赋值给前一个节点，根节点的右子树为新根节点
                pre = root
                root = root.right
        if x and y:
            x.val, y.val = y.val, x.val
```



96，不同的二叉搜索树，中等

核心方法：遍历序列`[1..n]`，每个i作为根，`[1, ..., i-1]`作为左子树，`[i+1, ..., n]`作为右子树。包含重叠子问题，所以可以使用动态规划。

定义两个函数：

+ $G(n)$: 长度为 *n* 的序列能构成的不同二叉搜索树的个数。
+ $F(i, n)$: 以 *i* 为根、序列长度为 *n* 的不同二叉搜索树个数 (1≤*i*≤*n*)。

$G(n) = \sum_{i=1}^nF(i,n)$

当序列长度为1（只有根）或0（空树）时，只要一种情况，即$G(0)=1$, $G(1)=1$

给定序列 1⋯*n*，我们选择数字 *i* 作为根，则根为 *i* 的所有二叉搜索树的集合是左子树集合和右子树集合的**笛卡尔积**

那么$F(i, n) = G(i-1)G(n-i)$，两个公式进行结合后，得到状态转移方程

$G(n) = \sum_{i=1}^nG(i-1)G(n-i)$ 

时间复杂度：O(n^2)

空间复杂度：O(n)

```python
class Solution:
    def numTrees(self, n):
        """
        :type n: int
        :rtype: int
        """
        G = [0]*(n+1)
        G[0], G[1] = 1, 1

        for i in range(2, n+1):
            for j in range(1, i+1):
                G[i] += G[j-1] * G[i-j]

        return G[n]
```

$G(n)$函数的值在数学上被称为[卡塔兰数](https://baike.baidu.com/item/catalan/7605685?fr=aladdin) $C_n$。公式表示为：

$C_0 = 1, C_{n+1} = \frac {2(2n+1)}{n+2} C_n$

时间复杂度 : O(n)
空间复杂度 : O(1)

```python
class Solution(object):
    def numTrees(self, n):
        """
        :type n: int
        :rtype: int
        """
        C = 1
        for i in range(0, n):
            C = C * 2*(2*i+1)/(i+2)
        return int(C)
```



437，路径总和3，中等

记录每条路径上的前缀和。前缀和。就是到达当前元素的路径上，之前所有元素的和。只需计算每一步中，sum在数组sumlist中出现的次数，然后与每一轮递归的结果相加即可。count计算本轮sum在数组sumlist中出现的次数

时间复杂度：O(n)，每个节点遍历一遍

空间复杂度：O(n)，递归栈空间需要的大小

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def pathSum(self, root: TreeNode, targetSum: int) -> int:
        def dfs(root, sumlist):
            if not root:
                return 0
            sumlist = [num + root.val for num in sumlist]
            sumlist.append(root.val)

            count = 0
            for num in sumlist:
                if num == targetSum:
                    count += 1
            
            return count + dfs(root.left, sumlist) + dfs(root.right, sumlist)
        return dfs(root, [])
```



114，二叉树展开为链表，中等

核心方法：前序遍历二叉树，将每个节点保存到列表中，然后遍历列表，将每个节点的左子树设定为None，将右子树设定为列表中的下一个节点

时间复杂度：O(n)，其中 n 是二叉树的节点数。前序遍历的时间复杂度是 O(n)，前序遍历之后，需要对每个节点更新左右子节点的信息，时间复杂度也是 O(n)。

空间复杂度：O(n)，空间复杂度取决于栈（递归调用栈或者迭代中显性使用的栈）和存储前序遍历结果的列表的大小

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def flatten(self, root: TreeNode) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        preorderList = list()

        def preorderTraversal(root: TreeNode):
            if root:
                preorderList.append(root)
                preorderTraversal(root.left)
                preorderTraversal(root.right)
        
        preorderTraversal(root)
        size = len(preorderList)
        for i in range(1, size):
            prev, curr = preorderList[i - 1], preorderList[i]
            prev.left = None
            prev.right = curr
```

使用迭代的方法：

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def flatten(self, root: TreeNode) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        preorder = list()
        stack = list()
        node = root
        while node or stack:
            while node:
            	preorder.append(node)
                stack.append(node)
                node = node.left
            node = stack.pop()
            node = node.right
            
        size = len(preorderList)
        for i in range(1, size):
            prev, curr = preorderList[i - 1], preorderList[i]
            prev.left = None
            prev.right = curr
```

核心方法：前序遍历和展开同步进行，需要栈

使用前面的方法，在节点展开后会破坏二叉树的结构而丢失子节点的信息，主要是由于对左子树遍历时，没有存储右子树的信息，而是在左子树遍历完毕后才会获得右子树信息。需要使用栈，在遍历左子树之前就存储左右子节点的信息，然后就可以将前序遍历和展开同时进行。

这种做法只适用于迭代方法。每次从栈内弹出一个节点作为当前访问的节点，获得该节点的子节点，如果子节点不为空，则依次将右子节点和左子节点压入栈内（注意入栈顺序）。

时间复杂度：O(n)

空间复杂度：O(n)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def flatten(self, root: TreeNode) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        if not root:
            return 
        # 开始遍历前，需要将prev设置为None
        stack = [root]
        prev = None
        while stack:
            curr = stack.pop()  # 每次从栈中弹出一个节点
            if prev:
                # 如果prev不为空，重新开始拼接
                prev.left = None
                prev.right = curr
            left, right = curr.left, curr.right
            # 这里注意左右子树的入栈顺序
            # 因为前序，需要保证下一次弹出的是左子树，所以左子树要比右子树后入栈
            if right:
                stack.append(right)
            if left:
                stack.append(left)
            # 更新前一个节点
            prev = curr
```

核心方法：寻找前驱节点

+ 如果一个节点的左子节点为空，则该节点不需要进行展开；如果左子节点不为空，那么左子树的最后一个节点（也就是左子树的最后一个节点）被访问之后，节点的右子节点被访问；此时左子树最右边的节点就是要找的前驱节点。
+ 对于当前节点，如果左子树节点不为空，则在其左子树中找到最右边的节点，最为前驱节点，将当前节点的右子节点赋给前驱节点的右子节点，然后将当前节点的左子节点赋给当前节点的右子节点，并将当前节点的左子节点设为空。对当前节点处理结束后，继续处理链表中的下一个节点，直到所有节点处理完。

时间复杂度：O(n)

空间复杂度：O(1)

```python
class Solution:
    def flatten(self, root: TreeNode) -> None:
        curr = root
        while curr:
            if curr.left:
                # last 表示前驱节点，nxt当前节点的左子节点
                last = nxt = curr.left
                while last.right:
                    # 一直找到左子树的最右节点，即前驱节点
                    last = last.right
                # 当前节点的右子树赋值给前驱节点的右子树
                last.right = curr.right
                # 当前节点左子树置为空，右子树为左子树
                curr.left = None
                curr.right = nxt
            # curr移向链表的最后一个
            curr = curr.right
```



538，把二叉搜索树转化为累加树，中等

核心方法：中序遍历

+ 首先使用递归中序遍历，将每个节点的值全部取出来
+ 然后再使用一次迭代的中序遍历，找到每个节点应该赋予的值，也就是上一次遍历结果的数组，索引开始的位置向后求和，每次处理完一个节点后，索引+1

时间复杂度：O(n)

空间复杂度：O(n)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def convertBST(self, root: TreeNode) -> TreeNode:
        # 首先使用中序遍历一遍
        def inorder(node):
            if not node:
                return 
            inorder(node.left)
            res.append(node.val)
            inorder(node.right)
        # 获取中序遍历的结果
        res = list()
        inorder(root)
        # 使用迭代法进行中序遍历，然后每个点进行赋值
        stack = list()
        i = 0
        node = root
        while node or stack:
            while node:
                stack.append(node)
                node = node.left
            node = stack.pop()
            node.val = sum(res[i:])
            i += 1
            node = node.right
        return root
```

核心方法：反序中序遍历

本题中要求将每个节点的值修改为原来的节点值加上所有大于它的节点值之和。这样只需要反序中序遍历该二叉搜索树，记录过程中的节点值之和，并不断更新当前遍历到的节点的节点值，即可得到题目要求的累加树。

时间复杂度：O(n)

空间复杂度：O(n)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def convertBST(self, root: TreeNode) -> TreeNode:
        def reverseOrder(node):
            nonlocal total
            if node:
                reverseOrder(node.right)
                total += node.val
                node.val = total
                reverseOrder(node.left)
        
        total = 0
        reverseOrder(root)
        return root
```

Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其反序中序遍历规则总结如下：

+ 如果当前节点的右子节点为空，处理当前节点，并遍历当前节点的左子节点；

+ 如果当前节点的右子节点不为空，找到当前节点右子树的最左节点（该节点为当前节点中序遍历的前驱节点）；

  + 如果最左节点的左指针为空，将最左节点的左指针指向当前节点，遍历当前节点的右子节点；

  + 如果最左节点的左指针不为空，将最左节点的左指针重新置为空（恢复树的原状），处理当前节点，并将当前节点置为其左节点（相当于当前节点的右子节点处理完毕，要继续处理当前节点的左子节点）；

重复步骤 1 和步骤 2，直到遍历结束。

时间复杂度：O(n)，其中 n 是二叉搜索树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次。

空间复杂度：O(1)。只操作已经存在的指针（树的空闲指针），因此只需要常数的额外空间。

```python
class Solution:
    def convertBST(self, root: TreeNode) -> TreeNode:
        def getSuccessor(node: TreeNode) -> TreeNode:
            succ = node.right
            while succ.left and succ.left != node:
                succ = succ.left
            return succ
        
        total = 0
        node = root

        while node:
            if not node.right:
                total += node.val
                node.val = total
                node = node.left
            else:
                succ = getSuccessor(node)
                if not succ.left:
                    succ.left = node
                    node = node.right
                else:
                    succ.left = None
                    total += node.val
                    node.val = total
                    node = node.left
        return root
```



617，合并二叉树，简单

核心方法：递归

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:
        # 使用迭代式的方法，同时遍历两棵树，然后对应位置相加
        if not root1:
            return root2
        if not root2:
            return root1
        
        merged = TreeNode(root1.val + root2.val)
        merged.left = self.mergeTrees(root1.left, root2.left)
        merged.right = self.mergeTrees(root1.right, root2.right)
        return merged
```



450，删除二叉搜索树的节点，中等

+ 核心方法：==二叉搜索树的性质==
  + 中序遍历的结果是递增序列
  + 如果要找中序遍历序列中当前节点的下一个节点，即要找比当前节点大的最小节点，称为<font color=red>后继节点</font>。先取当前节点的右子节点，然后一直取左子节点，直到左子节点为空，上一个就是后继节点；
  + 如果要找中序遍历序列中当前节点的上一个节点，即要找比当前节点小的最大节点，称为<font color=red>前驱节点</font>。先取当前节点的左子节点，然后一直取右子节点，直到右子节点为空，上一个就是前驱节点；

+ 判断当前节点的值与要求值的大小关系，如果当前节点值小，那么就从当前节点的左子树中找；如果当前节点值大，那么就从当前节点的右子树中找；
+ <font color=red>删除的节点情况需要分开讨论</font>：
  + 要删除的恰好是末端节点，两个子节点都为空，那么直接返回空
  + 要删除的只有一个非空子节点，那么它要让这个孩子接替自己的位置，返回不空的那一个
  + 要删除的有两个子节点，麻烦了，为了不破坏 BST 的性质，A 必须找到左子树中最大的那个节点
+ 如果当前节点和要求值相同，那么需要检查左右子树是否为空，这样做的目的是，如果当前节点的值被删掉，那么为了维护二叉搜索树的性质，需要从右子树中找到一个最小值添加到当前节点的位置；然后右子树中必须再删掉这个最小值

时间复杂度：O(logN)，N为节点总数

空间复杂度：O(h)，h为树的高度

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
        def getMin(node):
            while node.left:
                node = node.left
            return node
        
        if not root:
            return 
        if root.val == key:
            # 下面两行即处理了要删除节点是叶子结点的情况，也处理了只有一个非空子节点的情况
            if not root.left: return root.right
            if not root.right: return root.left
            # 最后处理要删除的节点有两个子节点的情况
            # 获取右子树中的最小节点，根据二叉树性质，最小节点一定是在最左边
            minNode = getMin(root.right)
            root.val = minNode.val
            root.right = self.deleteNode(root.right, minNode.val)
        elif root.val > key:
            root.left = self.deleteNode(root.left, key)
        elif root.val < key:
            root.right = self.deleteNode(root.right, key)
        return root
```



109，有序链表转化二叉搜索树，中等

核心方法：分治

+ 为了构造出平衡的二叉搜索树，也就需要尽可能将链表的中位数（链表长度为奇数，中位数就是中间节点；链表长度为偶数，中位数就是中间两个节点）作为二叉树的根；小于中位数的元素组成左子树，大于中位数的元素组成右子树；
+ 使用分治的思想，递归对左右子树进行构造，找出对应的中位数作为根节点。使用「左闭右开」的方法，即 left 包含在链表中而 right 不包含在链表中。可以直接用 (left, mid) 以及 (mid.next, right) 来表示左右子树对应的列表了。并且，初始的列表也可以用 (head, null) 方便地进行表示，其中 null 表示空节点。

时间复杂度：O(nlogn)，n是链表长度。设长度为 n 的链表构造二叉搜索树的时间为 T(n)，递推式为：T(n)=2⋅T(n/2)+O(n) 其中 O(n) 为链表遍历的时间复杂度，根据主定理，T(n) = O(nlogn)。

空间复杂度：*O*(log*n*)，这里只计算除了返回答案之外的空间。平衡二叉树的高度为 *O*(log*n*)，即为递归过程中栈的最大深度，也就是需要的空间。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sortedListToBST(self, head: ListNode) -> TreeNode:
        def findMedium(left, right):
            # 找到给定链表的中位数
            fast = slow = left
            while fast != right and fast.next != right:
                fast = fast.next.next
                slow = slow.next
            return slow

        def buildTree(left, right):
            if left == right:
                return None
            # 高度相等，找到链表中点，作为二叉树的根
            mid = findMedium(left, right)
            # 构造树
            root = TreeNode(mid.val)
            root.left = buildTree(left, mid)
            root.right = buildTree(mid.next, right)
            return root
        return buildTree(head, None)
```

核心方法：分治 + 中序遍历优化 （利用）

上一种解法的时间复杂度的问题在于寻找中位数节点。但是构造出的二叉搜索树的中序遍历结果本身就是链表的结果，因为可以将分治与中序遍历结合起来。

+ 首先计算出链表的长度，然后使用双闭区间，指定left和right的编号，那么中位数节点对应的编号为 `mid = (left + right + 1) // 2` （可以尝试举例证明）
+ 左右子树对应的编号范围分别是 [left, mid-1] [mid+1, right]，如果 left > right，那么遍历到的位置对应着一个空节点，否则对应着二叉搜索树中的一个节点。

时间复杂度：O(n)。其中 n 是链表的长度。设长度为 n 的链表构造二叉搜索树的时间为 T(n)，递推式为 T(n)=2⋅T(n/2)+O(1)，根据主定理，T(n)=O(n)。

空间复杂度：O(logn)

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sortedListToBST(self, head: ListNode) -> TreeNode:
        def getLength(head):
            # 获得链表长度
            length = 0
            while head:
                length += 1
                head = head.next
            return length
        
        def buildTree(left, right):
            if left > right:
                return None
            mid = (left + right + 1) // 2
            root = TreeNode()
            # 中序遍历
            root.left = buildTree(left, mid-1)
            nonlocal head
            root.val = head.val
            head = head.next
            root.right = buildTree(mid+1, right)
            return root

        length = getLength(head)
        return buildTree(0, length-1)
```



124，二叉树中的最大路径和，困难

这个题和二叉树中的最大直径那个题非常像，都是使用后序遍历，然后维护一个最大值（那里是直径，这里是节点值的和）

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def maxPathSum(self, root: TreeNode) -> int:
        self.maxNum = float('-inf')  # 用来存储（root+left+right的最大值）
        def dfs(r):
            # 每次首先检查root是否为空，空则返回0
            if not r: 
                return 0
            # 使用后序遍历
            left = dfs(r.left)  # 比较当前节点的左子树上所有值与0谁大，取大
            right = dfs(r.right)  # 比较当前节点的右子树上所有值与0谁大，取大
            self.maxNum = max(self.maxNum, left + right + r.val)
            return max(0, max(left, right) + r.val)
        dfs(root)
        return self.maxNum
```



297，二叉树的序列化与反序列化，中等

核心方法：二叉树的层级遍历 + 队列

序列化和反序列化都使用了队列

+ 对于序列化来说，使用二叉树的层次遍历，如果遇到空节点则加入#号，否则将元素转化为字符串添加进列表中，完成后将列表转化为字符串，前后加上`[ ]`
+ 对于反序列化来说，将上次得到数据去掉前后`[ ]`，转化为列表；第一个元素为树的根节点，加入队列，开始遍历列表；每次从队列中弹出一个数，转化为int型后转化为树节点，列表最前面的两个元素就是该树节点的左右子节点（如果两个元素为空， 那么令树节点的左右子节点等于空）
+ 时间复杂度：序列化和反序列化都是 O(n)
+ 空间复杂度：O(n)，因为使用了队列

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Codec:
    NULL = '#'
    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        # 使用层次遍历法
        if not root:
            return 
        res = list()
        queue = [root]
        while queue:
            node = queue.pop(0)
            if not node:
                # 如果遇到空指针，则向结果中加入空指针表示符，再加入分隔符
                res.append(self.NULL)
                continue
            res.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
       	return '[' + ','.join(res) + ']' # 将列表转化为字符串


    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        if not data:
            return 
        nodes = data[1:-1].split(',')  # 去掉前后中括号，将字符串转化为列表
        # 列表中第一个元素就是树的根节点
        root = TreeNode(int(nodes[0]))
        queue = [root]  # 初始化队列
        i = 1
        while i < len(nodes):
            # 队列中存储的是父节点
            parent = queue.pop(0)
            # 处理父节点的左子节点
            left = nodes[i]
            if left != self.NULL:  # 当前元素不能等于#
                parent.left = TreeNode(int(left))  # 将新建节点，接在父节点后面
                queue.append(parent.left)  # 新节点加入队列中
            else:
                parent.left = None
            i += 1
            # 处理父节点的右子节点
            right = nodes[i]
            if right != self.NULL:
                parent.right = TreeNode(int(right))
                queue.append(parent.right)
            else:
                parent.right = None
            i += 1
        return root

# Your Codec object will be instantiated and called as such:
# ser = Codec()
# deser = Codec()
# ans = deser.deserialize(ser.serialize(root))
```



145，二叉树的后序遍历，简单

核心方法：迭代

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        if not root: return list()
        stack = []
        prev = None
        res = list()

        while root or stack:
            while root:
                # 找到最左子节点，沿路的root全部入栈
                stack.append(root)
                root = root.left
            # 弹出栈顶，即最左子节点
            root = stack.pop()
            if not root.right or root.right == prev:
                # 如果右子树为空，或右子树等于前一个节点（表示除根节点外，所有子节点都处理过了）
                # 当前root加入结果
                res.append(root.val)
                # 当前root赋值给prev
                prev = root
                # root为空，表示不需要找最左子节点
                root = None
            else:
                # 如果root有右子节点，那么继续将root入栈，找root右子节点
                stack.append(root)
                root = root.right
        return res
```



958，二叉树的完全性检验，中等

核心方法：BFS

对于根节点，我们定义其编号为 `1`。然后，对于每个节点 `v`，我们将其左节点编号为 `2 * v`，将其右节点编号为 `2 * v + 1`。我们可以发现，树中所有节点的编号按照广度优先搜索顺序正好是升序。（也可以使用深度优先搜索，之后对序列排序）。

然后，我们检测编号序列是否为无间隔的 `1, 2, 3, …`，事实上，我们只需要检查最后一个编号是否正确，因为最后一个编号的值最大。

+ 时间复杂度：O(n)
+ 空间复杂度：O(n)

```python
class Solution:
    def isCompleteTree(self, root: TreeNode) -> bool:
        nodes = [(root, 1)]
        i = 0
        while i < len(nodes):
            node, v = nodes[i]
            i += 1  # i 用来记录节点个数
            if node:
                # 即使当前节点的左子树或者右子树为空，也要把空节点加进去
                nodes.append((node.left, 2*v))
                nodes.append((node.right, 2*v+1))
        # 最后只要判断节点列表中最后一个节点的编号和节点列表长度是否相等即可
        return nodes[-1][1] == len(nodes)
```



449，序列化与反序列化二叉搜索树，中等

核心遍历：后序遍历优化树结构的空间

+ 二叉搜索树的性质表明，只要我们获得了前序序列或后序序列，相当于我们知道了中序序列，可以通过排序获得。直接使用后序遍历完成序列化。
+ 对于反序列化，后序遍历的最后一位一定是根节点，然后指定最大值为无穷大，最小值为无穷小，对于当前根节点的右子树（二叉搜索树的右子树值一定比根节点大），最大值为无穷大，最小值为当前根节点值；对于当前节点的左子树（二叉搜索树的左子树一定比根节点小），最大值为当前根节点值，最小值为无穷小值。当然能够这样处理，是因为每次重建一个新节点时，都要把节点值pop出来

+ 时间复杂度：O(N)
+ 空间复杂度：O(N)

```python
class Codec:
    def serialize(self, root: TreeNode) -> str:
        """Encodes a tree to a single string.
        """
        # 根据后序遍历进行序列化
        def postorder(root):
            return postorder(root.left) + postorder(root.right) + [root.val] if root else []
        return ' '.join(map(str, postorder(root)))
        

    def deserialize(self, data: str) -> TreeNode:
        """Decodes your encoded data to tree.
        """
        def helper(lower = float('-inf'), upper = float('inf')):
            if not data or data[-1] < lower or data[-1] > upper:
                return None
            val = data.pop()  # 这句最能体现后序遍历的优势
            root = TreeNode(val)
            root.right = helper(val, upper)
            root.left = helper(lower, val)
            return root

        data = [int(num) for num in data.split(' ') if num]
        return helper()
```



144，二叉树的前序遍历，简单

时间复杂度：O(n)

空间复杂度：O(n)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        # 递归方法
        return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right) if root else []
    	
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        # 迭代方法
        res = list()
        node = root
        stack = list()
        while stack or node:
            while node:
                res.append(node.val)
                stack.append(node)
                node = node.left
            node = stack.pop()
            node = node.right
        return res

class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        # 莫里斯遍历，空间复杂度为O(1)
        res = list()
        if not root:
            return res
        
        while root:
            if root.left:
                tmp = root.left
                while tmp.right and tmp.right != root:
                    tmp = tmp.right
                
                if not tmp.right:
                    res.append(root.val)
                    tmp.right = root
                    root = root.left
                else:
                    tmp.right = None
                    root = root.right
            else:
                res.append(root.val)
                root = root.right
        return res
```



513，找树最下角的值，中等

核心方法：BFS + 队列 + 临时变量

使用一个中间变量保存每层的第一个节点。然后依次将队列中的节点出栈，在左右子树存在的情况下将左右子树依次入栈。当原始队列长度个节点全部出栈后，如果队列为空，说明没有下一层的节点入栈，那么当前中间变量保存的节点值就是要求的值。

+ 时间复杂度：O(n)
+ 空间复杂度：O(n)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findBottomLeftValue(self, root: TreeNode) -> int:
        queue = collections.deque([root])
        while queue:
            tmp = queue[0]
            for _ in range(len(queue)):
                node = queue.popleft()
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            if not queue:
                return tmp.val
```

核心方法：BFS + 队列 + 列表存储

使用一个列表保存，每层节点中的第一个节点值，队列中则保存每个节点和其所在的层数。每次弹出所在层数的节点时，判断存储列表的长度是否小于所在层数，如果小，就将当前节点（也就是每一层的第一个节点）的值加入到列表中。全部遍历完成后，弹出存储列表最后一个值，即最后一层的第一个值。

+ 时间复杂度：O(n)
+ 空间复杂度：O(n)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findBottomLeftValue(self, root: TreeNode) -> int:
        layer_head, queue = list(), collections.deque([(root, 1)])
        index = 1
        while queue:
            for _ in range(len(queue)):
                node, index = queue.popleft()
                if len(layer_head) < index:
                    layer_head.append(node.val)
                index += 1
                if node.left:
                    queue.append((node.left, index))
                if node.right:
                    queue.append((node.right, index))
        return layer_head.pop()
```

核心方法：DFS + 字典

使用字典保存每一层的第一个节点的值，字典的键为层数index；由于是先遍历左子树，后遍历右子树，并且层数不在字典中时才向字典中添加键值对，所以能够保证结果的正确性。最后需要将字典的值全部取出然后pop出来。

+ 时间复杂度：O(n)
+ 空间复杂度：O(n)，字典占用的空间

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findBottomLeftValue(self, root: TreeNode) -> int:
        d = dict()
        def dfs(root, index):
            if not root:
                return
            if index not in d:
                d[index] = root.val
            dfs(root.left, index + 1)
            dfs(root.right, index + 1)

        dfs(root, 1)
        return list(d.values()).pop()
```



863，二叉树中所有距离为K的节点，中等

+ 核心方法：
  + 将每个节点添加一个父节点的指向，使用DFS。
  + 然后以target为起点，标注为0，使用BFS以target为中心向左子树，右子树，父节点开始延伸，邻居每扩大一层，标注+1。直到从队列中pop出来的节点标注为k，此时从队列中弹出所有的距离为k的节点。

+ 时间复杂度：O(n)，树中每个节点访问一次
+ 空间复杂度：O(n)，队列和哈希集合

```python
class Solution:
    def distanceK(self, root: TreeNode, target: TreeNode, k: int) -> List[int]:
        # 将所有的节点都添加一个指向父节点的指针
        def dfs(node, parent):
            if node:
                node.parent = parent
                dfs(node.left, node)
                dfs(node.right, node)
        
        dfs(root, None)
        queue = collections.deque([(target, 0)])
        seen = {target}  # 记录访问过的节点
        while queue:
            if queue[0][1] == k:
                # 当队列中第一个元素满足条件时，整个队列的元素都满足条件
                return [node.val for node, _ in queue]
            node, d = queue.popleft()
            for neigh in (node.left, node.right, node.parent):
                if neigh and neigh not in seen:
                    # 邻居节点不为空，且没有被访问过，就将这个节点作为下一圈的节点
                    queue.append((neigh, d+1))
                    seen.add(neigh)
        return []
```

核心方法：计算节点之间的距离（推荐）

+ DFS返回节点到target之间距离dist，subTreeAdd将子树中与当前节点距离k-dist的所有节点加入结果
+ 时间复杂度：O(n)，树中每个节点访问一次
+ 空间复杂度：O(n)，队列和哈希集合

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def distanceK(self, root: TreeNode, target: TreeNode, k: int) -> List[int]:
        # 将所有的节点都添加一个指向父节点的指针
        def dfs(node):
            if not node:
                # 当前节点为空，返回-1
                return -1
            elif node == target:
                subTreeAdd(node, 0)
                return 1
            else:
                # 非子树中的距离节点主要在这里进行查找
                # 找到左子树中，target 与 node.left 和 node.right 的距离
                L, R = dfs(node.left), dfs(node.right)
                if L != -1:
                    if L == k:
                        ans.append(node.val)
                    # 如果target在node的左子树中，那么相应的要去找右子树中与node距离L+1的节点
                    subTreeAdd(node.right, L+1)
                    return L+1
                elif R != -1:
                    if R == k:
                        ans.append(node.val)
                    # 如果target在node的右子树中，那么相应的要去找左子树中与node距离R+1的节点
                    subTreeAdd(node.left, R+1)
                    return R+1
                else:
                    return -1
                
        
        def subTreeAdd(node, dist):
            # 找到子树中，与当前节点距离为 k-dist 的所有节点，加入答案
            if not node:
                return
            elif dist == k:
                ans.append(node.val)
            else:
                subTreeAdd(node.left, dist+1)
                subTreeAdd(node.right, dist+1)

        ans = list()
        dfs(root)
        return ans
```



补充题目：<font color=red>二叉树的下一个节点</font>。给定一个二叉树的一个节点，找到中序遍历下该节点的下一个节点。注意，树中的结点不仅包含左右子结点，**而且包含指向父结点的指针**。

核心方法：节点(设为x)中序遍历的下一个节点有以下可能：

+ 若x有右子树。则x的下一个节点为x右子树最左侧节点（考虑中序遍历）。如，2的下一个节点为8。
+ 若x没有右子树，又分为2种情况。
  + 若x是父节点的左孩子。则x的父节点就是x的下一个节点。如，7的下一个节点是4。
  + 若x是父节点的右孩子。则沿着父节点向上，直到找到一个节点的父节点的左孩子是该节点，则该节点的父节点就是x的下一个节点。如，9的下一个节点是1
  + <font color=red> 其实两种情况可以合并为一种情况，就是找第一个当前节点是其父节点左孩子的节点</font>
+ 时间复杂度：O(logn)
+ 空间复杂度：O(1)

```python
# class TreeLinkNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#         self.next = None
class Solution:
    def GetNext(self, pNode):
        if pNode.right:
            # 如果右子树存在，那么下一个节点就是右子树中最左节点
            pr = pNode.right
            while pr.left:
                pr = pr.left
            return pr
        # 右子树不存在，向上找到第一个当前节点是其父节点左孩子的节点
        p = pNode
        while p.next:
            if p.next.left == p:
                return p.next
            p = p.next
        # 找到根节点还没找到，就返回空
        return None
```



199，二叉树的右视图，中等

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rightSideView(self, root: TreeNode) -> List[int]:
        rightmost_value_at_depth = dict() # 深度为索引，存放节点的值

        queue = deque([(root, 0)])
        while queue:
            node, depth = queue.popleft()

            if node is not None:

                # 由于每一层最后一个访问到的节点才是我们要的答案，因此不断更新对应深度的信息即可
                rightmost_value_at_depth[depth] = node.val

                queue.append((node.left, depth + 1))
                queue.append((node.right, depth + 1))

        return list(rightmost_value_at_depth.values())
```

