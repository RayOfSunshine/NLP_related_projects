### 回溯算法相关

观点：深度优先遍历，递归，栈三者的关系，背后的统一逻辑都是【后进先出】

1. 回溯法：
   + 采用试错的思想，分步解决一个问题
   + 当现有分布答案不能解决问题时，则取消上一步甚至上几步的计算，再通过其他的，可能的分步解答尝试其他答案
   + 常使用递归
   + 重复计算的结果是：
     + 找到一个可能存在的答案
     + 尝试所有组合或可能后发现没有答案

2. 深度优先搜索
   + 用于便利或者搜索树（图）的算法，尽可能深的搜索树的分支
   + 当节点`v`的所在边都已经被探寻过，搜索将回溯到发现结点 `v` 的那条边的起始结点。直到访问完所有节点

3. 二者联系：
   + 【回溯算法】强调了【深度优先遍历】思想的用途，用一个 **不断变化** 的变量，在尝试各种可能的过程中，搜索需要的结果。强调了 **回退** 操作对于搜索的合理性。
   + 【深度优先遍历】强调一种遍历的思想
   + 搜索和遍历的区别：
     + 搜索问题的解，可以通过 **遍历** 实现。
     + 回溯算法用于 **搜索一个问题的所有的解** ，通过深度优先遍历的思想实现。
   + 【回溯】与【动态规划】的区别：
     + 共同点：求解多阶段决策问题
       + 求解一个问题分为很多步骤（阶段）
       + 每一个步骤（阶段）可以有多种选择
     + 不同点：
       + 【动态规划】只需要求我们评估最优解是多少，对应的具体解不要求，用于评估方案效果
       + 回溯算法可以搜索得到所有的方案（当然包括最优解），本质上是遍历，时间复杂度很高。
4. 搜索的方法：
   + 按顺序枚举每一位可能出现的情况，已经选择的数字在 **当前** 要选择的数字中不能出现。按照这种策略搜索就能够做到 **不重不漏**。
5. 逻辑：
   + 状态：变量的不同值
   + 状态重置：状态变量需要设置为和先前一样，也就是撤回上一次的选择
   + 深度优先遍历：往下走时在路径`path`变量尾部添加，撤销时在`path`变量尾部撤销，`path`变量就是栈。【深度优先遍历】通过【回溯】操作，实现了全局使用一份状态变量的效果
   + 从树的根节点到叶子结点形成的路径就是其中一个全排列
6. 设计状态变量：
   + 递归结构
   + 递归终止条件，当前程序递归到第几层
   + 布尔数组，表示哪些数还没有选择过，选择过的用True，没有选择过的用False
7. 为什么不使用广度优先遍历：
   + 深度优先遍历中每两个状态之间只相差一个位置的变化，退回比较容易；但是广度优先由浅层转到深层状态变化比较大；
   + 深度优先直接使用系统栈，而广度优先遍历则需要使用队列，存储每一步的状态信息，可能会产生很大的冗余
8. 剪枝
   + 回溯算法会应用「剪枝」技巧达到以加快搜索速度。有些时候，需要做一些预处理工作（例如排序）才能达到剪枝的目的。预处理工作虽然也消耗时间，但能够剪枝节约的时间更多；



#### 广度优先遍历

1. 寻找最短路径的问题



46，全排列，中等

核心方法：回溯

难点：

1. 需要传入深度优先遍历的参数
   + 不变的参数：数组本身，数组长度
   + 变化的参数：每次的排列`path`，存储排列的结果`res`，递归到的层数`depth`，还可以选择的元素数组`used`
2. 存储结果时，需要将排列结果拷贝一份，再加入结果中；这里使用`path[:]`，因为原始列表的变量名只是提供了一个指向列表的指针，如果直接使用`res.append(path)`，那么传入的只是这个指针，会随着path变化而变化，最后的结果会是6个空列表（由于path最终会回到初始值`[]`），而不是排列。
3. 复杂度分析
   + 时间复杂度：*O*(*N*×*N*!)，全排列个数 *N*!，每个全排列占空间 *N*。取较大者。
   + 空间复杂度：*O*(*N*)，递归的栈空间大小

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        def dfs(nums, n, depth, path, used, res):
            if depth == n:
                res.append(path[:])
			# 开始遍历整个数组
            for i in range(n):
                # 如果当前遍历到的元素没有被使用，那么就可以被使用
                if not used[i]:
                    used[i] = True
                    path.append(nums[i])
					# 开始递归
                    dfs(nums, n, depth+1, path, used, res)
					# 开始回溯，对当前位置的值进行撤回，使用状态恢复为未使用
                    used[i] = False
                    path.pop()
                    
        def dfs1(path, depth):
            # 这个方法占用的空间比较大，耗时比较多
            # 创建很多中间变量，这些中间变量有些是不需要的
            if depth == n:
                res.append(path)
                return res
            for i in range(n):
                if not used[i]:
                    used[i] = 1
                    dfs(path + [nums[i]], depth+1)
                    used[i] = 0

        n = len(nums)
        if n == 0: return []
        
        used = [False for _ in range(n)]
        res = list()
        # 开始进行树的搜索
        dfs(nums, n, 0, [], used, res)
        return res
```



22，括号生成，中等

此题已经记录过了，可以参考之前【数组】代码

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        # 哪些还没有选择过，使用L和R表示左右括号剩余可用的个数
        def dfs(cur_str, L, R):
            if L == 0 and R == 0:
                # 递归终止条件
                res.append(cur_str)
                return 
            if right < left:
                # 剪枝，代表递归结束，右括号的数量一定是大于左括号的
                return 
            if L > 0:
                # 如果左括号还有，则继续添加，右括号情况相同
                dfs(cur_str + '(', L-1, R)
            if R > 0:
                dfs(cur_str + ')', L, R-1)
        
        res = []
        dfs('', n, n)
        return res
```



剑指offer38，字符串的排列，中等

核心方法：回溯

难点：如果原始字符串中包含重复字符，需要在每层循环开始之前设置一个集合，因为每次开始新的一轮回溯，相当于是获取一个新位置的值；那么加在每层循环前的集合，就是针对这个位置进行去重的。也就是说，如果这个位置已经存在了相同的值，那么直接跳到下一个元素。这样比较有效

+ 时间复杂度：时间复杂度 $O(N!N)$ ： N 为字符串 s 的长度；时间复杂度和字符串排列的方案数成线性关系，方案数为 $N \times (N-1) \times (N-2) … \times 2 \times 1$ ，即复杂度为 $O(N!)$  。

+ 空间复杂度 $O(N^2)$ ： 全排列的递归深度为 $N$ ，系统累计使用栈空间大小为 $O(N)$ ；递归中辅助 `Set` 累计存储的字符数量最多为 $N + (N-1) + ... + 2 + 1 = (N+1)N/2$ ，即占用 $O(N^2)$ 的额外空间。


```python
class Solution:
    def permutation(self, s: str) -> List[str]:
        self.res = []
        self.ans = ''
        n = len(s)

        def backtrack(s):
            if len(self.ans) == n:
                self.res.append(str(self.ans))
                return
            dic = set()  # 设立哨兵集合来阻挡重复进入
            for i in range(0,len(s)):
                if s[i] in dic: continue  # 重复则略过此次循环，称为剪枝
                dic.add(s[i])  # 记得不在的时候需要放入set
                self.ans += s[i]
                backtrack(s[:i] + s[i+1:])  # 排除掉当前的i，将s中剩余的字符串再进行回溯
                self.ans = self.ans[:-1]
        backtrack(s)
        return list(self.res)
```



10，正则表达式匹配，困难

核心方法：回溯

难点：查找`s`和`p`的每个位置是否匹配

+ 如果只有`'.'`的情况，我们需要从左到右依次判断`s[i]`和`p[i]`是否匹配
+ 如果有`'*'`，会出现在p[1]的位置
  + 如果匹配0个，那么忽略`'*'`以及前面的字符，继续比较下一个
  + 如果匹配一个或多个，那么忽略掉s中的第一个元素，继续比较下一个

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        # 终止条件：如果p为空，如果s为空则为True（两个都查找完了）
        # 如果s不为空，则为False，表示不能匹配上，因为s还有剩余
        if not p: return not s
        # 第一个字母是否匹配
        # 即判断s是否有剩余，p[0]是否等于s[0]或者'.'
        first_match = bool(s and p[0] in {s[0],'.'})
        # 如果 p 第二个字母是 *
        if len(p) >= 2 and p[1] == "*":
            # self.isMatch(s, p[2:]) 表示忽略掉p中的前两个，这时可以不考虑第一个位置是否匹配，因为即使第一个位置没有匹配到，p[:2]匹配的也是0个
            # 或者 first_match 为 True
            return self.isMatch(s, p[2:]) or first_match and self.isMatch(s[1:], p)
        else:
            return first_match and self.isMatch(s[1:], p[1:])
```

核心方法：动态规划（推荐）

难点：`dp[i][j]` 表示的状态是 `s` 的前 `i` 项和 `p` 的前 `j` 项是否匹配。

已知了 `dp[i-1][j-1]` 的状态，分三种情况确定 `dp[i][j]` 的状态

+ `s[i] == p[j] or p[j] == '.'`时`dp[i][j] = dp[i-1][j-1] = True`
+ `p[j] == '*'`，星号与前面的字符相关，比较星号前面的字符 `p[j-1]` 和 `s[i]` 的关系。
  + `p[j-1] != s[i]`：如果星号前一个字符匹配不上，星号匹配了 0 次。应忽略这两个字符，看 `p[j-2]` 和 `s[i]` 是否匹配。 这时 `dp[i][j] = dp[i][j-2]`。
  + `p[j-1] == s[i] or p[j-1] == '.'`：星号前面的字符可以与 `s[i]` 匹配，这种情况下，星号可能匹配了前面的字符的 0 个，也可能匹配了前面字符的多个。当匹配 0 个时，这时我们需要去掉 p 中的 `b*` 或 `.*` 后进行比较，即 `dp[i][j] = dp[i][j-2]`；当匹配多个时，我们需要将 `s[i]` 前面的与 p 重新比较，即 `dp[i][j] = dp[i-1][j]`
+ 其他情况为不匹配，即 `dp[i][j] = False`

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        # 边界条件，考虑 s 或 p 分别为空的情况
        if not p: return not s
        if not s and len(p) == 1: return False
		
        m, n = len(s) + 1, len(p) + 1
        # 所有初始状态全部设置为 False
        dp = [[False for _ in range(n)] for _ in range(m)]
        # 初始状态
        dp[0][0] = True
        dp[0][1] = False
		
        # 当 s 为空字符串时，p字符串能否与之匹配需要分情况讨论
        # 如果s为空，p等于'a*'时，那么s与p是匹配的，此时 dp[0][2] = dp[0][0]
        # 缺少的2就是'a*'的长度2
        for c in range(2, n):
            # 在这个循环中n是取不到的，当时由于n = len(p) + 1，c 可以取到p的最后一个字符
            # 实际在状态转移的过程中，如果已经确定[j]的情况了，那么之后只需要关注[j+1]的情况
            # 所以这里和后面都使用了相同的处理方法：j = c - 1 和 i = r - 1
            j = c - 1  # 判断时使用j，使用c进行状态转移
            if p[j] == '*':
                dp[0][c] = dp[0][c - 2]
        
        # r, c都是从1的位置开始进行状态转移的，因为0的位置是初始化时完成的
        # 但是
        for r in range(1,m):
            i = r - 1
            for c in range(1, n):
                j = c - 1
                if s[i] == p[j] or p[j] == '.':
                    dp[r][c] = dp[r - 1][c - 1]
                elif p[j] == '*':       # ‘*’前面的字符匹配s[i] 或者为'.'
                    if p[j - 1] == s[i] or p[j - 1] == '.':
                        dp[r][c] = dp[r - 1][c] or dp[r][c - 2]
                    else:                       # ‘*’匹配了0次前面的字符
                        dp[r][c] = dp[r][c - 2] 
        return dp[m - 1][n - 1]
```



131，分割回文串，中等

核心方法：回溯+动态规划

难点：定义`dp[i][j]`为`s[i..j]`是否是回文串。这里i选择从后向前进行遍历，是原因的。如果从前向后进行遍历，且我们知道，`dp[i][j]是依赖于dp[i+1][j-1]`，这时`s[i+1]`可能还未遍历到，初始值并不一定就是动态规划结束后的值，而从后往前遍历就没有这个问题

+ 时间复杂度：$O(n \cdot 2^n)$，其中 n 是字符串 s 的长度。在最坏情况下，s 包含 n 个完全相同的字符，因此它的任意一种划分方法都满足要求。而长度为 n 的字符串的划分方案数为 $2^{n-1}=O(2^n)$，每一种划分方法需要 $O(n)$ 的时间求出对应的划分结果并放入答案，因此总时间复杂度为 $O(n \cdot 2^n)$。
+ 空间复杂度：数组 *f* 需要使用的空间为 $O(n^2)$

```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        # 采用回溯 + 动态规划预处理
        n = len(s)
        dp = [[True] * n for _ in range(n)]
        
        # 使用动态规划首先将所有s的所有子串全部预处理出来
        for i in range(n-1, -1, -1):
            for j in range(i+1, n):
                # s[i..j]是回文串的条件：头尾字符相等，且s[i+1..j-1]是回文串
                # 或者 i >= j: 也就是同一个字符，或者是空串，所以这里的j从i+1开始
                dp[i][j] = (s[i] == s[j]) and dp[i+1][j-1]

        res = list()
        ans = list()

        # 深度优先遍历
        def dfs(i):
            # 终止条件：当起始值i等于终点值n，表示遍历完毕
            if i == n:
                res.append(ans[:])
                return 
            
            for j in range(i, n):
                if dp[i][j]:
                    ans.append(s[i:j+1])
                    dfs(j+1)  # 下一个位置进行递归
                    ans.pop()
        dfs(0)
        return res
```



93，复原IP地址，中等

```python
class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        def isValid(s, start, end):
            """传入：字符串s，开始处理s的起始位置，字符串s末尾索引"""
            if start > end:
                # 如果已经超出去了，就返回无效
                return False
            if s[start] == '0' and start != end:
                # 如果第一位是0，而且这个IP段长度大于1，返回无效
                # start != end 表示这一个IP段的长度已经大于1了，此时的s是添加"."后的结果，
                # end表示s末尾索引，如果start表示第4个IP段的第一个字符索引
                # 如果有效，那么s[start]==0时，start = end，否则无效
                return False
            num = 0
            for i in range(start, end + 1):
                if s[i] > '9' or s[i] < '0':
                    # 字符如果大于9或者小于0，返回无效
                    return False
                num = num*10 + ord(s[i]) - ord('0')
                if num > 255:
                    # 转为int型后，如果超出边界，则无效
                    return False
            # 都不满足，则返回有效
            return True

        def backtracking(s, startindex, pointnum):
            """
            传入【字符串s，起始位置，"."的个数】
            """
            if pointnum == 3:
                # 在字符串中插入了3个"."时，说明已将s划分完成，此时进行有效性判断
                if isValid(s, startindex, len(s)-1):
                    # 如果返回有效，则将结果添加到res中
                    res.append(s)
                return  # 剪枝
            for i in range(startindex, len(s)):
                # 此处i为s的所有索引
                if isValid(s, startindex, i):
                    # 这里的有效性判断，主要是为了验证已划分出来的，最右边的区间是否有效
                    # 这里相当于添加并移动了“.”的位置在整个s中
                    s = s[:i+1] + '.' + s[i+1:]
                    pointnum += 1
                    backtracking(s, i+2, pointnum)  # 这里+2是由于中间插入了一个"."
                    # 这里传入的i+2作为下一次的startindex，表示的是下一个待处理的字符
                    pointnum -= 1  # 不满足这个条件时，pointnum-1表示去掉上一个区间的划分
                    # 去掉上一个添加的"."，接下来重新进行循环，重新分配"."的位置
                    s = s[:i+1] + s[i+2:]  
                else:
                    break
        
        # 如果字符串长度大于12，则直接返回空
        if len(s) > 12:
            return []
        res = list()
        # 下面的第一个0，表示每个IP字段（长度为3）中当前指向的位置，在0，1，2三个数当中的一个
        backtracking(s, 0, 0)
        return res
```



468，验证IP地址，中等

核心方法：使用分治，将每个序列的分隔符分开后，判断每个部分是否是满足条件的，只要不满足就返回‘Neither’，否则返回对应的验证结果

+ 时间复杂度：O(1)
+ 空间复杂度：O(1)

```python
class Solution:
    def validate_IPv4(self, IP):
        nums = IP.split('.')
        for x in nums:
            if len(x) == 0 or len(x) > 3:
                # 检查长度
                return 'Neither'
            if x[0] == '0' and len(x) != 1 or not x.isdigit() or int(x) > 255:
                # 开头为0，但长度大于1；整体不是一个数字，如加入了字母；转为整型后大于255，返回不是
                return 'Neither'
        return 'IPv4'

    def validate_IPv6(self, IP):
        nums = IP.split(':')
        haxdigits = '0123456789abcdefABCDEF'
        for x in nums:
            if len(x) == 0 or len(x) > 4 or not all(c in haxdigits for c in x):
                # 检查长度，并且检查x中的所有字母是否都出现在十六进制字符串中
                return 'Neither'
        return 'IPv6'
    
    def validIPAddress(self, IP: str) -> str:
        if IP.count('.') == 3:
            return self.validate_IPv4(IP)
        elif IP.count(':') == 7:
            return self.validate_IPv6(IP)
        return 'Neither'
```



79，单词搜索，中等

核心方法：回溯，函数 `check(i,j,k)` 判断从网格的 `(i,j)` 位置出发，能否搜索到单词`word[k..]`，`word[k..]` 表示 `word` 中从位置 `k` 开始的子串

复杂度分析：

+ 时间复杂度：在每次调用函数 $\text{check}$ 时，除了第一次可以进入 4 个分支以外，其余时间我们最多会进入 3 个分支。由于单词长为 L，故 $\text{check(i, j, 0)}$ 的时间复杂度为 $O(3^L)$，而我们要执行 $O(MN)$ 次检查，其中 *M*,*N* 为网格的长度与宽度。一个非常宽松的上界为 $O(MN \cdot 3^L)$
+ 空间复杂度：$O(MN)$。我们额外开辟了 $O(MN)$ 的 $\textit{visited}$ 数组，同时栈的深度最大为 $O(\min(L, MN))$。

```python
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        # 对于每个位置，只有上下左右四个方向可以移动，这里的元组表示的是移动的方向
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

        def check(i: int, j: int, k: int) -> bool:
            if board[i][j] != word[k]:
                # 当前位置上已经不匹配了，就返回 False
                return False
            if k == len(word) - 1:
                # 能够遍历到字符串的末尾，就返回 True
                return True
            
            visited.add((i, j))  # 访问过的位置要添加
            result = False
            for di, dj in directions:
                # 从四个方向中依次选取并改变新位置
                newi, newj = i + di, j + dj
                if 0 <= newi < len(board) and 0 <= newj < len(board[0]):
                    # 需要保证边界没有超出
                    if (newi, newj) not in visited:
                        # 剪枝，访问过的位置就不能再访问了
                        if check(newi, newj, k + 1):
                            result = True
                            break
            
            visited.remove((i, j))  # 退出这一轮添加的位置
            return result

        h, w = len(board), len(board[0])
        visited = set()
        # 将每一个位置作为初始值，进行 check(i, j, 0) 检查，有一个能匹配上就返回 True
        for i in range(h):
            for j in range(w):
                if check(i, j, 0):
                    return True
        
        return False
```



17，电话号码的字母组合，中等

核心方法：回溯。回溯的循环部分为：维护一个字符串，表示已有的字母排列，该字符串初始为空。每次取电话号码的一位数字，从哈希表中获得该数字对应的所有可能的字母，并将其中的一个字母插入到已有的字母排列后面，然后继续处理电话号码的后一位数字

时间复杂度：$O(3^m \times 4^n)$，其中 m 是输入中对应 3 个字母的数字个数（包括数字 2、3、4、5、6、8），n 是输入中对应 4 个字母的数字个数（包括数字 7、9），$m+n$ 是输入数字的总个数。

空间复杂度：$O(m+n)$，空间复杂度主要取决于哈希表以及回溯过程中的递归调用层数，哈希表的大小与输入无关，可以看成常数，递归调用层数最大为 *m*+*n*。

```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits:
            return list()
        
        phoneMap = {
            "2": "abc",
            "3": "def",
            "4": "ghi",
            "5": "jkl",
            "6": "mno",
            "7": "pqrs",
            "8": "tuv",
            "9": "wxyz",
        }

        def backtrack(index: int):
            if index == len(digits):
                combinations.append("".join(combination))
            else:
                digit = digits[index]
                for letter in phoneMap[digit]:
                    # 每次从一个数字对应的字母中获取一个，然后移动到下一个数字
                    combination.append(letter)
                    backtrack(index + 1)
                    combination.pop()

        combination = list()  # 存放每一种字母的组合
        combinations = list()
        backtrack(0)
        return combinations
```



78，子集，中等

核心方法：回溯

难点：区别于之前的几个题目，这个题目没有终止条件，因为需要寻找子集，每个子集的长度也没有规定，因此只要递归一次，就保留一次的结果。

时间复杂度：$\textit{nums}$ 中枚举其所有 $2^n$ 个子集，每个子集加入答案时需要拷贝一份，耗时 $O(n)$。那么最终的时间复杂度为$O(n \times 2^n)$

空间复杂度：使用栈，栈的最长度为n，所以O(n)

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        def dfs(idx, tmp):
            # 没有终止条件，每次回溯时直接将上一轮tmp结果赋给res就行
            res.append(tmp[:])
            # 回溯循环：
            for i in range(idx, len(nums)):
                tmp.append(nums[i])
                dfs(i+1, tmp)
                tmp.pop()

        res = []
        dfs(0, [])
        return res
```

核心方法：迭代

找规律，在 [[]] 的基础上加上 [1]，得到的结果中，对每个元素加上 [2]，以此类推

+ 时间复杂度：O(n*2^n)，结果1个变2个，2个变4个，4个变8个
+ 空间复杂度：O(2^n)，中间数组的临时列表

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        # 迭代方法
        res = [[]]
        for i in nums:
            res = res + [[i] + num for num in res]  # 使用一个临时数组空间
        return res
```



90，子集2，中等

核心方法：回溯。与上一题不同是，解集中不能出现重复的子集。所以在出现重复元素时，应当通过索引平移的方式跳过相同的元素。另外，为了保证上述操作能够通过，还需要对原始数组进行排序。其余结构与上一个代码相同

时间复杂度：排序的时间复杂度为 $O(n \log n)$。最坏情况下 $\textit{nums}$ 中无重复元素，需要枚举其所有 $2^n$ 个子集，每个子集加入答案时需要拷贝一份，耗时 $O(n)$。那么最终的时间复杂度为$O(n \times 2^n)$

空间复杂度：使用栈，栈的最长度为n，所以O(n)

```python
class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        def dfs(idx, tmp):
            res.append(tmp[:])
            for i in range(idx, len(nums)):
                # 出现重复元素时，应当通过索引平移的方式跳过相同的元素
                if i > idx and nums[i] == nums[i-1]:
                    continue
                tmp.append(nums[i])
                dfs(i+1, tmp)        
                tmp.pop()

        res = list()
        nums.sort()  # 对原数组进行排序
        dfs(0, [])
        return res
```



39，组合总和，中等

核心方法：回溯+栈

难点：每次深度遍历时，需要判断当前组合的和是否等于`target`：如果等于`target`，那么将组合添加到结果中；如果和大于target，说明超出了，直接返回空，也就是需要弹出最后一个元素，重新选取。在for循环中，如果当前元素已经大于`target`了，那么直接跳出当前循环。

时间复杂度：

空间复杂度：使用栈空间，最长为 $O(n)$

```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        if min(candidates) > target: return []
        candidates.sort() 
        res = list()

        def dfs(idx, tmp, target):
            if target == 0:
                res.append(tmp[:])
            if target < 0:
                return
            for i in range(idx, len(candidates)):
                if candidates[i] > target:
                    break
                tmp.append(candidates[i])
                target -= candidates[i]
                dfs(i, tmp, target)
                tmp.pop()
                target += candidates[i]

        dfs(0, [], target)
        return res
    
# 或者使用下面这种方法
class Solution(object):
    def combinationSum(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        if min(candidates) > target:
            return []
        candidates.sort()
        res = []

        def helper(candidates, target, temp_list):
            if target == 0:
                res.append(temp_list)
            if target < 0:
                return
            for i in range(len(candidates)):
                if candidates[i] > target:
                    break
                # 这里每次传入的是，截断后的candidates，减去新增值的target，更新后的组合
                helper(candidates[i:], target - candidates[i], temp_list + [candidates[i]])
        helper(candidates,target,[])
        return res
```



77，组合，中等

核心方法：回溯

难点：方法比较固定，要注意终止条件是当临时组合的元素个数等于k时，来达到的。也要注意组合中的元素和索引可以合二为一

时间复杂度：$\textit{nums}$ 中枚举其所有 $2^n$ 个子集，每个子集加入答案时需要拷贝一份，耗时 $O(n)$。那么最终的时间复杂度为$O(n \times 2^n)$

空间复杂度：使用栈，栈的最长度为n，所以O(n)

```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        def dfs(idx, tmp):
            if len(tmp) == k:
                res.append(tmp[:])
                return
            for i in range(idx, n+1):
                tmp.append(i)
                dfs(i+1, tmp)
                tmp.pop()

        res = list()
        dfs(1, [])
        return res
```



40，组合总和2，中等

核心方法：回溯+排序

难点：对于给定数组中元素有重复，且每个组合中每个元素只能使用一次的要求，一定要想到使用首先使用排序，然后在深度优先遍历的循环中，判断当前元素是否等于上一个元素，如果等于，则要跳过这个元素，再进行下一层深度回溯。

时间复杂度：排序的时间复杂度为 $O(n \log n)$。最坏情况下 $\textit{nums}$ 中无重复元素，需要枚举其所有 $2^n$ 个子集，每个子集加入答案时需要拷贝一份，耗时 $O(n)$。那么最终的时间复杂度为$O(n \times 2^n)$

空间复杂度：使用栈，栈的最长度为n，所以O(n)

```python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        if min(candidates) > target: return []
        candidates.sort() 
        res = list()

        def dfs(idx, tmp, target):
            if target == 0:
                res.append(tmp[:])
            if target < 0:
                return
            for i in range(idx, len(candidates)):
                if candidates[i] > target:
                    break
                if i > idx and candidates[i] == candidates[i-1]:
                    continue
                tmp.append(candidates[i])
                target -= candidates[i]
                dfs(i+1, tmp, target)
                tmp.pop()
                target += candidates[i]

        dfs(0, [], target)
        return res
```



216，组合总和3，中等

核心方法：回溯+剪枝

+ 注意要控制的变量有两个，n，k，参考之前的解法，当k与n都等于0时，才能得到一种组合
+ 时间复杂度：$O({M \choose k} \times k)$，其中 M 为集合的大小，本题中 M 固定为 9。一共有 $M \choose k$ 个组合，每次判断需要的时间代价是 O(k)。
+ 空间复杂度：O(M)。path 数组的空间代价是 O(k)，递归栈空间的代价是 O(M)，故空间复杂度为 O(M+k)=O(M).

```python
class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        if n < 6: return []  # 剪枝
        res = []
        def backtrack(num, path, k, n):
            if k == 0 and n == 0:
            	# 要求的组合个数满足，且和满足，结果才会添加
                res.append(path[:])
            if n < 0 or k < 0:  # 剪枝
                return 
            for cn in range(num, 10):
                if cn > n:  # 剪枝
                    break
                path.append(cn)
				# 回溯，当前数+1，要求个数-1，和-当前数
                backtrack(cn + 1, path, k - 1, n - cn)
                path.pop()
            return 

        backtrack(1, [], k, n)
        return res
```





51，N皇后，困难

核心方法：回溯

难点：

+ 任何两个皇后都不能在同一行，同一列，或是同一条斜线上。每一行有且仅有一个皇后，每一列有且仅有一个皇后，每一条斜线上有且仅有一个皇后。
+ 使用一个数组记录每行放置的皇后的列下表，依次在每行放置一个皇后。每次新放置的皇后都不能和已经放置的皇后在同一列和同一斜线上，并更新数组中当前行的皇后列下表，当N个皇后都放置完毕，则找到一个可能的解。
+ 第1个皇后有n种选择，第2个皇后有n-1种选择，第3个皇后有n-2个选择，所以时间复杂度为为O(N!)
+ 当找到一个可能解后，将数组转换为表示棋盘状态的列表，并将该棋盘状态的列表加入结果列表中
+ 为了降低时间复杂度，每次放置皇后时需要快速判断每个位置是否可以放置皇后。最理想的情况是在O(1)时间复杂度内判断该位置所在的列和斜线上是否已经有皇后
+ 使用三个集合，`columns`, `diagonals1`, `disgonals2` 分别记录每一列和两个方向上的每条斜线是否有皇后。列表上很直观，斜线的表示分为两种情况
  + 从左上到右下的情况，同一斜线下，行下标和列下标之差相等
  + 从右上到左下的情况，同一斜线下，行下标和列下标之和相等
  + 每次放置皇后时，对于每个位置判断其是否在三个集合中，如果三个集合都不包含当前位置，则当前位置是可以放置皇后的。
+ 复杂度分析
  + 时间复杂度：*O*(*N*!)，其中 N*N* 是皇后数量。
  + 空间复杂度：*O*(*N*)，空间复杂度主要取决于递归调用层数、记录每行放置的皇后的列下标的数组以及三个集合，递归调用层数不会超过 N，数组的长度为 N，每个集合的元素个数都不会超过 N。

```python
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        def generateBoard():
            # 将结果转化为棋盘的形式
            board = list()
            for i in range(n):
                # 这里的queens的每一个位置都已经更新了列下标，以这个列下标为索引，将row中每行指定索引对应的数赋值为Q
                row[queens[i]] = "Q"
                board.append("".join(row))
                row[queens[i]] = "."  # 将对应位置更新为.方便下一次使用
            return board

        def backtrack(r: int):
            # r 表示行数，从第一行开始遍历，到最后一行时，则获得了一个解
            if r == n:
                board = generateBoard()
                solutions.append(board)
            else:
                for i in range(n):
                    # 此时的i表示这个皇后所在的列下标，要求该列下标不在列集合中，且行下标的差不在斜线集合1中，且列下标的和不在斜线集合2中
                    if i in columns or r - i in diagonal1 or r + i in diagonal2:
                        continue
                    queens[r] = i  # r行i列的位置可以放置皇后
                    columns.add(i)
                    diagonal1.add(r - i)
                    diagonal2.add(r + i)
                    backtrack(r + 1)  # 回溯传递的是每一行
                    columns.remove(i)
                    diagonal1.remove(r - i)
                    diagonal2.remove(r + i)
                    
        solutions = list()
        queens = [-1] * n  # 记录每个可以放置皇后的列下标
        columns = set()
        diagonal1 = set()
        diagonal2 = set()
        row = ["."] * n
        backtrack(0)
        return solutions
```



44，通配符匹配，困难

核心方法：动态规划。本题和正则表达式相比，比较相似。不同的是，正则表达式匹配的是，字符P中的通配符还需要和其前一个字符组成后再与`s`中的字符串进行匹配；而这里的`p`中的单个字符就能与`s`中的字符进行匹配。

难点：

+ 使用 `dp[i][j]` 表示 `s` 中前`i`个字符能否和`p`中的前`j`个字符进行匹配
+ 状态转移
  + 如果`p_j`是字母，那么`s_i`必须与`p_j`相等，公式为：`dp[i][j] = p[j] == s[i] & dp[i-1][j-1]`
  + 如果`p_j`是`?`号，那么`s_i`都可以，公式为：`dp[i][j] = dp[i-1][j-1]`
  + 如果`p_j`是`*`号，有两种情况，使用或者不使用
    + 如果使用，就是匹配多个`s`，那么`dp[i][j] = dp[i-1][j]`
    + 如果不使用，就是匹配空，那么`dp[i][j] = dp[i][j-1]`
  + 前两个状态转移可以进行合并，最终为：
    + `dp[i][j] = dp[i-1][j-1]`，当`p[j]`等于问号，或`p[j]`==`s[i]`
    + `dp[i][j] = dp[i-1][j] or dp[i][j-1]`，当`p[j]`等于`*`时
    + False，other situation
+ 边界条件
  + `dp[0][0]=True`，两个都为空，可以匹配
  + `dp[i][0]=False`，`p`为空，一定不能匹配
  + `dp[0][j]` 需要分情况讨论：因为星号才能匹配空字符串，所以只有当模式 `p` 的前 `j` 个字符均为星号时，`dp[0][j]` 才为真
  + `dp[0][j]` 在 `j` 大于模式 `p` 的开头出现的星号字符个数之后，值也恒为假，而 `dp[i][j]` 的默认值（其它情况）也为假，因此在对动态规划的数组初始化时，我们就可以将所有的状态初始化为 `False`，减少状态转移的代码编写难度。
  + 最终的答案即为 `dp[m][n]`，其中 `m` 和 `n` 分别是字符串 `s` 和模式 `p` 的长度。
+ 复杂度分析：
  + 时间复杂度：*O*(*mn*)，其中 *m* 和 *n* 分别是字符串 *s* 和模式 *p* 的长度。
  + 空间复杂度：*O*(mn)，即为存储所有 (*m*+1)(*n*+1) 个状态需要的空间。

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        m, n = len(s), len(p)
		
        # 对所有边界条件进行初始化
        # m+1 目的是保证行能够取到 m
        # 但是 n+1 又是为什么？
        dp = [[False] * (n + 1) for _ in range(m + 1)]
        dp[0][0] = True
        # 这里不从 0 开始取 i 是因为 dp[0][0]的值已经确定了
        # n+1 是为了保证 i=n 能够取到
        for i in range(1, n + 1):
            if p[i - 1] == '*':
                dp[0][i] = True
            else:
                break
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if p[j - 1] == '*':
                    dp[i][j] = dp[i][j - 1] | dp[i - 1][j]
                elif p[j - 1] == '?' or s[i - 1] == p[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
                
        return dp[m][n]
```



841，钥匙和房间，中等

核心方法：深度优先搜索

题目要求的是，从第0号节点出发是否能够达到所有的节点。可以使用深度优先搜索的方式遍历整张图，统计可以到达的节点个数，并利用数组vis标记当前节点是否访问过，以防止重复访问。

+ 时间复杂度：O(m+n)，m表示所有房间中的钥匙数量的总数，n是房间数量
+ 空间复杂度：O(n)，递归的栈空间

```python
class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        def dfs(x):
            # 将当前房间数添加到访问历史中
            vis.add(x) 
            nonlocal num  # 把变量标记为自由变量
            num += 1  # 访问过的房间数+1
            for it in rooms[x]:
                # 从当前访问的房间中选取钥匙，选择没有访问过的房间（钥匙）进行递归
                if it not in vis:
                    dfs(it)

        n = len(rooms)  # 房间总数
        num = 0  # 能够进入房间的总数
        vis = set()  # 访问过的房间
        dfs(0)  # 从第一个房间开始递归
        # 如果所有的房间都访问过了，那么访问次数应该等于房间总数
        return num == n
```

<font color=red>推荐</font> 核心方法：广度优先搜索

使用队列先进先出的特点，依次尝试每个房间的所有钥匙，记录能够访问的房间数量

+ 时间复杂度：O(m+n)
+ 空间复杂度：O(n)，主要为队列的开销

```python
class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        n = len(rooms)
        num = 0
        vis = {0}
        que = collections.deque([0])

        while que:
            x = que.popleft()
            num += 1
            for it in rooms[x]:
                if it not in vis:
                    vis.add(it)
                    que.append(it)
        return num == n
```



967，连续差相同的数字，中等

核心方法：BFS

首先设定可选择的集合为1-9的数字，遍历N-1次，每次从这个集合中获取任意数字，判断自己的末位数字与K值的差或和是否在0-9之间； 如果满足这个条件，那么这个差或和拼接在原来的任意数字之后，就能够满足差值为K的条件。遍历N-1次后，这些值就产生了

**复杂度分析**

- 时间复杂度：O(2^N)*O*(2*N*)。
- 空间复杂度：O(2^N)*O*(2*N*)。

```python
class Solution(object):
    def numsSameConsecDiff(self, N, K):
        ans = {x for x in range(1, 10)}
        for _ in range(N-1):
			# 用来记录每一轮位置遍历后满足条件的备选数
            ans2 = set()
            for x in ans:
                d = x % 10
                # 需要满足当前数x的末尾d与K的差或和是在0-9之间的
                if d - K >= 0:
                    ans2.add(10*x + d-K)  # 将新值拼接在备选数之后
                if d + K <= 9:
                    ans2.add(10*x + d+K)
            # 每个位置的值遍历完毕后需要更新下一轮的备选方案
            ans = ans2

        # 长度为1时，0也是满足条件的，需要补充进去
        if N == 1:
            ans.add(0)

        return list(ans)
```

下面的代码和上面的思想一样，只是在表达上更准确

```python
class Solution:
    def cal(self, s):
        # 将s（一个数组）中的各个数组合
        res = 0
        for t in s:
            res = res * 10 + t
        return res
    
    def numsSameConsecDiff(self, n, k):
        Q = collections.deque()
        for i in range(1, 10):
            Q.append([i])
        res = []
        while Q:
            print(Q)
            v = Q.popleft()
            if len(v) == n:
                # 如果一组结果包含的数达到长度要求，那么将其合并后输入到返回结果中
                res.append(self.cal(v))
            elif k == 0:
                # 如果绝对差值为0，直接将同一个数补充进行
                v.append(v[-1])
                Q.append(v)
            else:
                if v[-1] - k >= 0:
                    # 这里注意：需要对列表进行复制
                    t = v.copy()
                    t.append(t[-1] - k)
                    Q.append(t)
                if v[-1] + k < 10:
                    t = v.copy()
                    t.append(t[-1] + k)
                    Q.append(t)
        return res
```



127，单词接龙，困难

核心方法：<font color=red>最短转换序列的长度，首先应当想到广度优先搜索，需要将其抽象为图</font>

将每个单词都抽象为一个点，如果两个单词可以通过指改变一个字母进行转化的，说明他们之间有一条双向边，把所有满足条件的点相连，就形成一个图。基于下面这个图，我们以beginWord为起点，以endWord为终点进行BFS，寻找最短路径

![单词接龙-BFS图](/Users/lixuanhong/Desktop/Materials/算法与数据结构/单词接龙-BFS图.png)

算法：

1. 首先给所有`wordList`中的单词进行编号，创建单词与`id`的映射字典；然后检查`endWord`是否在该字典中，如果不在返回`0`.
2. 然后建图，常见做法为取两两单词组合，判断他们是否恰好相差一个字符，来判断两个单词之间是否相连。效率比较低，需要优化。优化方法为：<font color=red>创建`3`个虚拟节点，针对`hit`，创建3个虚拟节点`*it`， `h*t`， `hi*`，并让hit向这三个虚拟节点分别连一条边即可。如果一个单词能够转化为hit，那么这个单词必然会连接到这三个虚拟节点之一。对于每一个单词，我们枚举它连接到的虚拟节点，把该单词对应的id与这些虚拟节点对应的id相连即可。</font>

3. 注意：beginWord加入队列开始BFS，到达endWord时的最短路径是包含了虚拟节点的，此时的最短路径是真实路径的两倍。还需要计算起点对最终答案的贡献，还需要+1

+ 时间复杂度：$O(N \times C)$。其中 $N$ 为 `wordList` 的长度，$C$ 为列表中单词的长度。
  + 建图过程中，对于每一个单词，我们需要枚举它连接到的所有虚拟节点，时间复杂度为 $O(C)$，将这些单词加入到哈希表中，时间复杂度为 $O(N \times C)$，因此总时间复杂度为 $O(N \times C)$。
  + 广度优先搜索的时间复杂度最坏情况下是 $O(N \times C)$。每一个单词需要拓展出 $O(C)$ 个虚拟节点，因此节点数 $O(N \times C)$。
+ 空间复杂度：$O(N \times C^2)$)。其中 N 为 wordList 的长度，C 为列表中单词的长度。哈希表中包含 $O(N \times C)$ 个节点，每个节点占用空间 $O(C)$，因此总的空间复杂度为 $O(N \times C^2)$。


```python
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]):
        def addWord(word):
            # 对每个词进行标号，nodeNum为单词编号，赋值后编号+1为下一次赋值准备
            if word not in wordId:
                nonlocal nodeNum
                wordId[word] = nodeNum
                nodeNum += 1

        def addEdge(word):
            addWord(word)
            id1 = wordId[word]  # 获取当前词id
            chars = list(word)  # 将单词拆成字母
            for i in range(len(chars)):
                # 将原单词中的每一个字母拿出来，替换为*，然后对其编号，并加入边关系中
                tmp = chars[i]
                chars[i] = '*'
                newWord = ''.join(chars)
                addWord(newWord)
                id2 = wordId[newWord]
                # 将两个节点互相作为对方的一个连接对象
                edge[id1].append(id2)
                edge[id2].append(id1)
                chars[i] = tmp

        wordId = dict()     # 存放单词-id的映射
        edge = collections.defaultdict(list)    # 记录每个节点和其他（虚拟）节点的边关系
        nodeNum = 0     # 用于节点编号

        for word in wordList:
            # 对每一个词建立边关系
            addEdge(word)

        # 将beginWord加入到边关系中
        addEdge(beginWord)
        if endWord not in wordId:
            return 0
        
        dis = [float('inf')] * nodeNum  # 初始化距离
        beginId, endId = wordId[beginWord], wordId[endWord] # 起点id，重点id
        dis[beginId] = 0    # 起点id对应距离设置为0

        que = collections.deque([beginId])  # 初始化双端队列
        while que:
            x = que.popleft()
            if x == endId:
                # 如果到达终点，可以返回结果
                return dis[endId] // 2 + 1
            for it in edge[x]:
                if dis[it] == float('inf'):
                    # 上面条件表示，已经访问过，并已经修改值的，就不能再修改了
                    # 更新距离：当前距离+1
                    dis[it] = dis[x] + 1
                    que.append(it)
        return 0
```

核心方法：双向广度优先搜索

广度优先搜索的搜索空间大小依赖于每层节点的分支数量。加入每个节点的分支数量相等，那么搜索空间会随着层数的增长指数级的增加。

使用两个同事进行的BFS可以有效的减少搜索空间。一边从beginWord开始，一边从endWord开始。每次从两边各扩展一层节点，当发现某一时刻两边都访问过同一节点时停止。

代码住要修改的部分在于初始化距离时

```python
		# 初始化起点距离，和对应双端队列
    	disBegin = [float("inf")] * nodeNum
        beginId = wordId[beginWord]
        disBegin[beginId] = 0
        queBegin = collections.deque([beginId])
		
        # 初始化终点距离，和对应双端队列
        disEnd = [float("inf")] * nodeNum
        endId = wordId[endWord]
        disEnd[endId] = 0
        queEnd = collections.deque([endId])

        while queBegin or queEnd:
            # 两个队列同时不为空
            queBeginSize = len(queBegin)
            for _ in range(queBeginSize):
                nodeBegin = queBegin.popleft()
                if disEnd[nodeBegin] != float("inf"):
                    # 重要！这个位置遍历过了，说明已找到这个位置，就返回结果
                    return (disBegin[nodeBegin] + disEnd[nodeBegin]) // 2 + 1
                for it in edge[nodeBegin]:
                    if disBegin[it] == float("inf"):
                        disBegin[it] = disBegin[nodeBegin] + 1
                        queBegin.append(it)

            queEndSize = len(queEnd)
            for _ in range(queEndSize):
                nodeEnd = queEnd.popleft()
                if disBegin[nodeEnd] != float("inf"):
                    return (disBegin[nodeEnd] + disEnd[nodeEnd]) // 2 + 1
                for it in edge[nodeEnd]:
                    if disEnd[it] == float("inf"):
                        disEnd[it] = disEnd[nodeEnd] + 1
                        queEnd.append(it)
        return 0
```



200，岛屿数量，中等

核心方法：DFS

如果一个位置为1，则以其为其实节点，开始进行DFS。在DFS过程中，每个被搜索到的1都会被重新标记为0，并且从这个位置开始，向其上下左右四个位置进行继续的DFS；如果被搜到的位置没有1，不进行任何操作。

+ 时间复杂度：O(mn)，m和n分别表示行数和列数
+ 空间复杂度：O(mn)，在最坏情况下，整个网格均为陆地，深度优先搜索的深度达到 mn。

```python
class Solution:
    def dfs(self, grid, r, c):
        # 将当前位置置为0
        grid[r][c] = '0'
        # 重新获取行列
        nr, nc = len(grid), len(grid[0])
        for x, y in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]:
            # 分别取上下左右四个位置的值，如果还等于，就继续dfs
            if 0 <= x < nr and 0 <= y < nc and grid[x][y] == '1':
                self.dfs(grid, x, y)


    def numIslands(self, grid: List[List[str]]) -> int:
        nr = len(grid)  # 获取网格的行数
        nc = len(grid[0])   # 获取网格的列数
        
        num_islands = 0 # 初始化岛屿数量
        for r in range(nr):
            for c in range(nc):
                if grid[r][c] == '1':
                    num_islands += 1
                    # 开始进行DFS
                    self.dfs(grid, r, c)
        return num_islands
```

核心方法：BFS

扫描整个网络，如果一个位置为1，将其加入队列，开始进行BFS，每个搜索到的 1 都会被重新标记为 0。直到队列为空，搜索结束。

+ 时间复杂度：*O*(MN)，其中 M 和 N 分别为行数和列数。
+ 空间复杂度：$O(\min(M, N))$，在最坏情况下，整个网格均为陆地，队列的大小可以达到 $\min(M, N)$。

```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        nr = len(grid)  # 获取网格的行数
        nc = len(grid[0])   # 获取网格的列数
        
        num_islands = 0 # 初始化岛屿数量
        for r in range(nr):
            for c in range(nc):
                if grid[r][c] == '1':
                    num_islands += 1
                    # 和dfs的区别主要从这里开始
                    grid[r][c] = '0'
                    neighbours = collections.deque([(r, c)])    # 初始化双端队列
                    # 开始进行BFS
                    while neighbours:
                        row, col = neighbours.popleft()
                        for x, y in [(row-1, col),(row+1, col),(row, col-1),(row, col+1)]:
                            if 0 <= x < nr and 0 <= y < nc and grid[x][y] == '1':
                                neighbours.append((x,y))
                                grid[x][y] = '0'
        return num_islands
```



695，岛屿的最大面积，中等

核心方法：BFS，方法和上一个题一样，区别在于使用队列时统计每个岛中1的个数

+ 时间复杂度：O(r*c)
+ 空间复杂度：O(r*c)

```python
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        nr, nc = len(grid), len(grid[0])
        ans = 0  # 记录最大面积
        for r in range(nr):
            for c in range(nc):
                if grid[r][c] == 1:
                    area = 1
                    grid[r][c] = 0
                    neightbours = collections.deque([(r, c)])
                    while neightbours:
                        row, col = neightbours.popleft()
                        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                            x, y = row + dx, col + dy
                            if 0 <= x < nr and 0 <= y < nc and grid[x][y] == 1:
                                area += 1
                                neightbours.append((x, y))
                                grid[x][y] = 0
                    ans = max(ans, area)
        return ans
```



994，腐烂的橘子，中等

核心方法：BFS（本题和岛屿数量很相似）

+ 首先需要确定在0时刻，总共有多少个腐烂的橘子，将腐烂橘子的坐标和时刻一同加入队列中
+ 开始广度优先搜索，从队列中弹出每个已经腐烂的橘子，从这个橘子的上下左右四个方向查找是否存在好的橘子；如果存在，那么将这个位置的值重新置为2，表示已经腐烂了，时刻+1，坐标和时刻加入队列。
+ 重复上述步骤，直到所有上下左右为1的位置全部遍历完毕。
+ 最后检查是否还有1，如果还有表示存在不能被影响的位置，结果返回-1；否则返回时刻

时间复杂度：O(nm) 即进行一次广度优先搜索的时间，其中 m=grid[0].length，m=grid[0].length 

空间复杂度：最多需要 O(nm) 的空间，即队列的大小

```python
class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        # 获取网格行列数
        R, C = len(grid), len(grid[0])

        # 记录所有腐烂橘子的位置
        queue = collections.deque()
        for r, row in enumerate(grid):
            for c, val in enumerate(row):
                if val == 2:
                    # 这里的0表示这些橘子是第0分钟开始腐烂的
                    # 将所有已经腐烂的橘子位置和时刻添加进队列中
                    queue.append((r, c, 0))
        
        # 定义四个方向的广度优先遍历
        def neighbours(r, c):
            for nr, nc in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]:
                if 0 <= nr < R and 0 <= nc < C:
                    yield nr, nc
        
        # 初始化时间，从第0分钟开始
        d = 0
        while queue:
            r, c, d = queue.popleft()
            for nr, nc in neighbours(r, c):
                if grid[nr][nc] == 1:
                    # 如果四个方向上有橘子，那么将这个位置和时刻加入队列，并重置值为2
                    grid[nr][nc] = 2
                    queue.append((nr, nc, d+1))
        
        # 检查全部腐烂后，是否还有剩余的1
        if any(1 in row for row in grid):
            return -1
        return d  
```



909，蛇梯棋，中等

核心方法：寻找最短路径的问题，使用广度优先遍历

注意：

+ 到达的点的坐标是需要计算的。这个点的坐标与这个点的标号和棋盘的长宽有关。由于棋盘中每个位置的标号是从左下开始蛇形赋值的，那么通过计算新点编号s-1与棋盘长度的商和余数，来找到这个点的坐标；
+ 因为棋盘上的位置是蛇形赋值的，所以在计算这个点的坐标时，需要注意列索引的值；在当前行下，行对2取余不等于棋盘长度对2取余时，选择当前余数；否则选择长度-1-余数
+ 创建一个字典，用来记录每个位置编号下走过的距离，当走到编号为n*n的位置时，返回字典中对应的距离，就是最小距离。
+ 当走到的位置是蛇或者梯子时，新节点的编号被替换为棋盘上的对应位置的数，也就是完成了通过蛇或梯子的跳跃，到达了新的位置
+ 到达新的位置需要更新位置编码与对应距离，并将当前编码加入队列

时间复杂度：$O(n^2)$

空间复杂度：$O(n^2)$

```python
class Solution:
    def snakesAndLadders(self, board: List[List[int]]) -> int:
        n = len(board)

        def get(s):
            # 获取新位置的坐标
            quot, rem = divmod(s-1, n)
            row = n - 1 - quot
            col = rem if row % 2 != n % 2 else n - 1 - rem
            return row, col

        dist = {1:0}
        queue = collections.deque([1])
        while queue:
            s1 = queue.popleft()
            if s1 == n*n:
                return dist[s1]
            for s2 in range(s1+1, min(s1+6, n*n)+1):
                r, c = get(s2)
                if board[r][c] != -1:
                    s2 = board[r][c]
                if s2 not in dist:
                    dist[s2] = dist[s1] + 1
                    queue.append(s2)
        return -1
```



301，删除无效括号，困难

- 所有的「括号匹配」问题，可能会用到的一个重要性质是：

  > **如果当前遍历到的左括号的数目严格小于右括号的数目则表达式无效**。

1. 我们可以遍历一次输入字符串，统计「左括号」和「右括号」出现的次数。

+ 当遍历到「右括号」的时候，
  + 如果此时「左括号」的数量不为 0，因为 「右括号」可以与之前遍历到的「左括号」匹配，此时「左括号」出现的次数 -1；如果此时「左括号」的数量为 0，「右括号」数量加 1；
+ 当遍历到「左括号」的时候，「左括号」数量 +1

<font color=red>通过这样的计数规则，最后「左括号」和「右括号」的数量就是各自最少应该删除的数量。</font>

2. 剪枝操作

我们设计变量 `leftCount` 和 `rightCount` 分别表示在遍历的过程中已经遍历到的左括号和右括号的数量，统计它们是为了方便<font color=red>剪枝</font>。这是因为 只有当「已经遍历到的左括号的数量」严格大于「已经遍历到的右括号的数量」的时候，才可以继续添加「右括号」。

3. 对于最后找到结果去重的问题，选择哈希表。

```python
class Solution:
    def removeInvalidParentheses(self, s: str) -> List[str]:
        # 统计原始字符串中左括号和右括号应该去掉的个数，其中右括号的匹配需要参考当前左括号的数量
        leftRemove, rightRemove = 0, 0
        for ch in s:
            if ch == '(':
                leftRemove += 1
            if ch == ')':
                if leftRemove == 0:
                    rightRemove += 1
                else:
                    leftRemove -= 1

        def dfs(idx, leftCount, rightCount, leftRemove, rightRemove, path):
            if idx == len(s):
                # 当前字符串全部遍历完，就返回递归位置
                if leftRemove == 0 and rightRemove == 0:
                    # 如果应当删除的左右括号数量全部为0，将当前情况添加进最终结果中
                    res.add(path)
                return
            # 1. 删除当前遍历字符
            if s[idx] == '(' and leftRemove:
                # 如果应删除的左括号数量不为0，递归遍历下一个字符，应删除左括号数量-1
                dfs(idx+1, leftCount, rightCount, leftRemove-1, rightRemove, path)
            if s[idx] == ')' and rightRemove:
                # 如果应删除的右阔后数量不为0，递归遍历下一个字符，应删除右括号数量-1
                dfs(idx+1, leftCount, rightCount, leftRemove, rightRemove-1, path)
            
            # 2. 保留当前遍历字符
            if s[idx] != '(' and s[idx] != ')':
                # 如果遍历到的不是括号，递归遍历下一个字符，当前字符加入当前模式
                dfs(idx+1, leftCount, rightCount, leftRemove, rightRemove, path + s[idx])
            elif s[idx] == '(':
                # 如果要保留左括号，递归遍历下一个字符，左括号数量+1，当前字符加入当前模式
                dfs(idx+1, leftCount+1, rightCount, leftRemove, rightRemove, path + s[idx])
            elif leftCount > rightCount:
                # 剪枝操作，左括号数量大于右括号数量，才能保留当前遍历到的右括号
                dfs(idx+1, leftCount, rightCount+1, leftRemove, rightRemove, path + s[idx])
            return 
        
        res = set()
        dfs(0, 0, 0, leftRemove, rightRemove, '')
        return list(res)
```



47，全排列2，中等

核心方法：回溯 + 剪枝 + 排序

这个题目与全排列1的区别在于，如果原始数组中存在相同的元素，那么包含这两个相同元素（虽然顺序不同）是属于同一种的排列的。也就是在需要剪枝，对于相同元素需要进行平滑；但是千万注意，平滑需要对数组进行<font color=red>排序</font>，否则不能实现平滑

复杂度分析

+ 时间复杂度：*O*(*N*×*N*!)，全排列个数 *N*!，每个全排列占空间 *N*。取较大者。
+ 空间复杂度：O(n)。我们需要 O(n) 的标记数组，同时在递归的时候栈深度会达到 O(n)，因此总空间复杂度为 O(n+n)=O(2n)=O(n)。

```python
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        def dfs(nums, n, depth, path, used, res):
            if depth == n:
                res.append(path[:])
            for i in range(n):
                if not used[i]:
                    if i > 0 and nums[i] == nums[i-1] and not used[i-1]:
                        # 注意：这里是与全排列1的区别，需要对相同元素进行平滑
                        # 同时也需要保证前一个元素也没有被使用，满足这些条件才可以continue
                        continue
                    used[i] = True
                    path.append(nums[i])
                    dfs(nums, n, depth+1, path, used, res)
                    used[i] = False
                    path.pop()

        res = list()
        n = len(nums)
        if n == 0:
            return []
        nums.sort()  # 注意：需要对数组进行排序
        used = [False for _ in range(n)]
        dfs(nums, n, 0, [], used, res)
        return list(res)
```



剑指offer33，二叉搜索树的后序遍历序列，中等

核心方法：递归 + dfs + 二叉搜索树的性质

后序遍历是先遍历左子树，然后遍历右子树，最后遍历根节点。根据二叉搜索树的性质，左子树节点的值都小于根节点，右子树节点的值都大于根节点。所以可以使用回溯的方式，每次将序列划分出左子树，右子树和根节点。根节点一定是最后一个数，那么只要这个序列能够完全分成这三个部分，那么我们续集按照上面的规则来验证左子树和右子树，一直递归下去。序列不满足的主要原因是，并没有将整个序列划分为3个部分，具体可以见代码。

+ 时间复杂度：O(N^2)，每次调用 recur(i,j) 减去一个根节点，因此递归占用 O(N) ；最差情况下（即当树退化为链表），每轮递归都需遍历树所有节点，占用 O(N) 。
+ 空间复杂度：O(N) ：最差情况下（即当树退化为链表），递归深度将达到 N。

```python
class Solution:
    def verifyPostorder(self, postorder: List[int]) -> bool:
        def dfs(i, j):
            if i >= j:
                return True
            p = i
            while postorder[p] < postorder[j]:
                # 寻找左子树
                p += 1
            m = p  # 记录左右子树划分的节点
            while postorder[p] > postorder[j]:
                # 寻找右子树
                p += 1
            # false主要来自于 p == j，表示一个序列并不能划分为左子树，右子树，根，三个部分
            return p == j and dfs(i, m-1) and dfs(m, j-1)
        
        return dfs(0, len(postorder)-1)
```

核心方法：单调栈

后序遍历的倒序按照【根节点，右子树，左子树】进行排列，使用单调栈存储遍历过程中单调递增的元素，（也就是能够先后将根节点和右子树加入栈中）。将那么在遍历这个排列时，如果遇到当前遍历元素小于栈顶元素时（此时的遍历元素就是某个根节点的左子树，接下来的操作就是要找到它的根节点），就不断出栈，更新当前遍历元素的根节点；更新完毕后，以左子树为根节点的左子树各节点都是小于刚更新过的根节点的，如果不满足这个条件，说明这个排列就不满足二叉搜索树的性质，直接返回False；全部遍历完毕，就返回True

https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/

时间复杂度：O(n)

空间复杂度：O(n)

```python
class Solution:
    def verifyPostorder(self, postorder: List[int]) -> bool:
        stack = []
        root = float('inf')
        for i in range(len(postorder)-1, -1, -1):
            if postorder[i] > root:
                return False
            while stack and postorder[i] < stack[-1]:
                root = stack.pop()
            stack.append(postorder[i])
        return True
```



89，格雷编码，中等

核心方法：回溯

+ 当n=1时，结果有0，1，两个数只有一个位置不相同；
+ 当n=2的时候，在上面的结果中分别添加0和1，得到的结果有，00，10，01，11；如果要满足相邻两个数之间的只有一位不相同，可以从中间将这个结果一分为二，将后半部分，也就是10，11翻转变为11，10，然后与前半部分进行拼接，得到的结果就能够满足条件：00，10，11，01
+ 当n=3时，给上一个结果加0，形成三位的2进制数4个，000，010，110，100 满足相邻两个只有一位不同。添加1也是如此 001，011，111，101，观察到同一个2位的2进制数添加0、添加1，可以作为两个相邻的数，所以想到把 100 和 101接起来。所以也就是将后面4个翻转然后和前半部分进行拼接，得到满足条件的结果

时间复杂度：O()

空间复杂度：O(n) 递归栈空间

```python
class Solution:
    def grayCode(self, n: int) -> List[int]:
        def gray(n):
            if n==0:
                return ["0"]
            if n==1:
                return ["0","1"]
            n_1 = gray(n-1)
            n_1_reverse = n_1[::-1]
            return [x+"0" for x in n_1]+[x+"1" for x in n_1_reverse]
        return [int(x,2) for x in gray(n)]
    
    
class Solution:
    def grayCode(self, n: int) -> List[int]:
        """或者使用回溯的方式（不推荐）
        """
        seen = set([0])  # 使用集合来处理是否访问过
        def backtrack(path):
            if len(path) == 2 ** n: 
                return path
            for i in range(n):
                # 精髓，首先对1进行左移，然后与上一个选定的数值做异或，得到结果就是一个潜在值
                nxt = 1 << i ^ path[-1]
                if nxt in seen: 
                    continue
                seen.add(nxt)
                path.append(nxt)
                if backtrack(path): 
                    return path
        return backtrack([0])
```



547，省份数量，中等

核心方法：DFS，哈希表集合

这个题其实是一种比较简单的连通分量求解问题。维护一个访问集合，首先获取一个城市，数量+1，然后遍历城市列表，也就是DFS，检查另外一个城市（可能与前一个城市是同一个）与前一省份是否连通，也就是`isConnected[i][j]==1`。如果满足条件，则将当前省份加入访问集合。当这个省份的全部完成后，也就意味着属于这个省份的城市已经全部找完了，于是再找下一个省份。

+ 时间复杂度：O(n^2)
+ 空间复杂度：O(n)，使用哈希集合

```python
class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        n = len(isConnected)
        circles = 0  # 初始化省份数量
        visited = set()
        def dfs(i):
            for j in range(n):
                if isConnected[i][j] == 1 and j not in visited:
                    visited.add(j)
                    dfs(j)
        
        for i in range(n):
            if i not in visited:
                dfs(i)
                circles += 1
        return circles
```

核心方法：使用队列来模拟递归的栈空间，时间空间复杂度与上面一致

```python
class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        n = len(isConnected)
        circles = 0  # 初始化省份数量
        visited = set()        
        for i in range(n):
            if i not in visited:  
                # i 其实表示的就是一个省份，但是在访问isConnected中的每个元素时
                # 才会将位置为1，对应的点（也表示一个省份）加入到已经访问过的集合中
                queue = collections.deque([i])
                while queue:
                    last = queue.popleft()
                    for j in range(n):
                        if isConnected[last][j] == 1 and j not in visited:
                            visited.add(j)
                            queue.append(j)
                # 所有相连的点全部被访问过后，省份数量+1
                circles += 1
        return circles
```

核心方法：使用并查集，初始时，每个城市都属于不同的连通分量。遍历矩阵 isConnected，如果两个城市之间有相连关系，则它们属于同一个连通分量，对它们进行合并。遍历矩阵 isConnected 的全部元素之后，计算连通分量的总数，即为省份的总数。

+ 时间复杂度：$O(n^2 \log n)$，其中 n 是城市的数量。需要遍历矩阵 isConnected 中的所有元素，时间复杂度是 $O(n^2)$，如果遇到相连关系，则需要进行 2 次查找和最多 1 次合并，一共需要进行 $2n^2$ 次查找和最多 $n^2$ 次合并，因此总时间复杂度是 $O(2n^2logn^2)=O(n^2logn)。$​
+ 空间复杂度：O(n)，使用数组长度为n

```python
class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        def find(index):
            # 找到ta
            if parents[index] != index:
                # 如果这里连通分量的头不等于当前索引，说明index的位置已经变化过了，
                # 那么要继续溯源，直到找到头，然后返回这个头
                parents[index] = find(parents[index])
            return parents[index]
        
        def union(index1, index2):
            # 合并两个连通分量
            parents[find(index1)] = find(index2)
        
        provinces = len(isConnected)
        parents = list(range(provinces))  # 初始化每个城市所在的连通分量就是它自己
		
        # 招任意两个点之间是否连通，如果连通，则将两个点相连
        for i in range(provinces):
            for j in range(i+1, provinces):
                if isConnected[i][j] == 1:
                    union(i, j)
        # 查找有几个省份的parent是他自己，那么省份数量就是几
        circles = sum([parents[i] == i for i in range(provinces)])
        return circles
```



50，pow(x, y)，中等

核心方法：回溯 + 快速幂

```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        def quickMul(N):
            ans = 1.0
            # 贡献的初始值为 x
            x_contribute = x
            # 在对 N 进行二进制拆分的同时计算答案
            while N > 0:
                if N % 2 == 1:
                    # 如果 N 二进制表示的最低位为 1，那么需要计入贡献
                    ans *= x_contribute
                # 将贡献不断地平方
                x_contribute *= x_contribute
                # 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可
                N //= 2
            return ans
        
        return quickMul(n) if n >= 0 else 1.0 / quickMul(-n)
```



797，所有可能的路径，中等

核心方法：深度优先遍历，从0开始，递归其每一个邻居，直到找到第n-1个值完成一条路径上的查找。

+ 时间复杂度：$O(2^N*N^2)$ 在最坏情况下，路径的数目是指数级别的，且代码中的 `path.add(0, node)` 对于一条路径需要的时间复杂度为 $O(N^2)$，因为在列表的开始位置插入节点的时间复杂度为 O(N)。这里存在优化的空间，例如可以改为在列表的结束位置插入节点，时间复杂度降低为 O(1)，在返回答案前，将所有列表翻转，这样均摊到列表中的每一个位置仍然是 O(1) 的，因此总时间复杂度可以降低为 $O(2^N *N)$​​​
+ 空间复杂度：$O(2^N*N)$​​，为在最坏情况下存储所有答案需要的空间。

```python
class Solution:
    def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:
        # 二维数组的第 i 个数组中的单元都表示有向图中 i 号结点所能到达的下一些结点
        # 所有 0 到 n-1 的路径，与就是一定要走到最后一个数
        def dfs(i, visited):
            # i 为当前点，visited 记录访问过的点
            if visited and visited[-1] == n-1:
                # 访问过的，最后一个点已经到达终点，则将结果添加
                ans.append(visited[:])
                return 
            for j in graph[i]:
                # 找到当前点链接的节点组，从中选取一个节点
                if j not in visited:
                    # 这个节点没有被访问过，那么以这个点为当前点，并将其标记为访问过，继续递归
                    visited.append(j)
                    dfs(j, visited)
                    visited.pop()
            return 
        
        ans, n = [], len(graph)
        dfs(0, [0])  # 从0出发
        return ans
```



934，最短的桥，中等

核心方法：DFS + BFS

- 时间复杂度：O(MN)，其中 M 和 N 分别是数组 `A` 的行数和列数。
- 空间复杂度：O(MN)。

```python
class Solution(object):
    def shortestBridge(self, A):
        R, C = len(A), len(A[0])

        def neighbors(r, c):
            for nr, nc in ((r-1,c),(r,c-1),(r+1,c),(r,c+1)):
                if 0 <= nr < R and 0 <= nc < C:
                    yield nr, nc

        # 首先利用stack做DFS，确定两个岛的所有的位置，并将两个岛进行划分
        def get_components():
            done = set()
            components = []
            for r, row in enumerate(A):
                for c, val in enumerate(row):
                    if val and (r, c) not in done:
                        # Start dfs
                        stack = [(r, c)]
                        seen = {(r, c)}
                        while stack:
                            node = stack.pop()
                            for nei in neighbors(*node):
                                if A[nei[0]][nei[1]] and nei not in seen:
                                    stack.append(nei)
                                    seen.add(nei)
                        done |= seen
                        components.append(seen)
            return components

        source, target = get_components()

        # 使用队列完成BFS，从其中一个岛的所有节点开始，标记深度为0.
        # 每次从这些节点中取出一个节点，朝四个方向延伸后得到的节点（深度+1）是否存在于另一个岛中
        # 若存在就返回深度，否则加入队列
        queue = collections.deque([(node, 0) for node in source])
        done = set(source)
        while queue:
            node, d = queue.popleft()
            if node in target: return d-1
            for nei in neighbors(*node):
                if nei not in done:
                    queue.append((nei, d+1))
                    done.add(nei)
```



130，被围绕的区域，中等

**核心方法**：DFS，**任何边界上的 `O` 都不会被填充为 `X`。** 我们可以想到，所有的不被包围的 `O` 都直接或间接与边界上的 `O` 相连。在边界上的和与边界相连的全部被标记为A。再遍历一次二维数组，将标记为A的重新标记为O，标记为O的全部标记为X

+ Time: O(mn)
+ Space: O(mn)

```python
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        m, n = len(board), len(board[0])
        
        def dfs(x, y):
            if not 0 <= x < m or not 0 <= y < n or board[x][y] != 'O':
                return 
            board[x][y] = 'A'  # 横纵坐标不越界，且为O
            dfs(x+1, y)
            dfs(x-1, y)
            dfs(x, y-1)
            dfs(x, y+1)

        # 首先检查每行边界
        for i in range(m):
            dfs(i, 0)
            dfs(i, n-1)
        
        # 再检查每列边界
        for j in range(1, n-1):  # 范围是0到n-1，因为第一列和最后一列已经处理过了
            dfs(0, j)
            dfs(m-1, j)

        # 再遍历一次，将所有标记为A的重新标记为O，所有标记为O的全部标记为X
        for i in range(m):
            for j in range(n):
                if board[i][j] == 'A':
                    board[i][j] = 'O'
                elif board[i][j] == 'O':
                    board[i][j] = 'X'
```



剑指offer13，机器人的运动范围，中等

**核心方法**：BFS，检查是否每个位置的索引所有位数的和都是小于等于k。使用一个集合保存所有满足条件的位置索引，当queue为空时，获取集合的长度，来确定有多少个位置是满足条件的。

+ 我们可以发现随着限制条件 k 的增大，(0, 0) 所在的蓝色方格区域内新加入的非障碍方格都可以由上方或左方的格子移动一步得到。因此可以将搜索方向缩减为向右或向下。

+ Time: O(mn)
+ Space: O(mn)

```python
class Solution:
    def digitsum(self, n):
        # 对每一个索引，每位上的数求和
        ans = 0
        while n:
            # 从最低位开始累加，每次向左更新原数
            ans += n % 10
            n //= 10
        return ans

    def movingCount(self, m: int, n: int, k: int) -> int:
        queue = collections.deque([(0, 0)])
        marked = set()
        while queue:
            x, y = queue.popleft()
            if (x, y) not in marked and 0 <= x < m and 0 <= y < n and self.digitsum(x) + self.digitsum(y) <= k:
                marked.add((x, y))
                for nx, ny in [(x+1, y), (x, y+1)]:
                    queue.append((nx, ny))
        return len(marked)
```

